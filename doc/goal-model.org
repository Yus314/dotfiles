* nix-shell
#+name: tmp-shell
#+BEGIN_SRC nix :noweb yes
  { pkgs ? import <nixpkgs> {} }:
  pkgs.mkShell { buildInputs = with pkgs; [ plantuml jdk]; }
  #+END_SRC
#+begin_src elisp :nix-shell tmp-shell :results output
  (setq org-plantuml-jar-path "/nix/store/03nh9m73gwwj477yralnsw70igwswfi5-plantuml-1.2025.3/lib/plantuml.jar")
#+end_src
* ゴールモデル
#+begin_src plantuml :nix-shell tmp-shell  :file ゴールモデル.png
  @startmindmap
  !theme materia

  ,* 継続的に進化する、再現可能な開発環境の実現

  ,**[#lightblue] 変更の容易性と拡張性を確保する

  ,*** 開発サイクルを高速化する
  ,**** 素早いビルドが行なえる
  ,***** 分散ビルドが行なえる
  ,****** root userでsshの接続を行なう
  ,***** キャッシュを利用する
  ,***** 自宅のデスクトップにsshを増設する
  ,**** 作業の自動化ができる
  ,***** 反映させたいホストにまとめて反映できる
  ,***** 機密情報も一括で管理を可能にする
  ,***** タスクランナーで普段行うタスクを素早く実行出来るようにする
  ,***** pre-commitでcommit前にlinterやformatterを適用する
  ,***** CIでビルドの確認をする
  ,***** Garbage Collectionを自動化する

  ,*** 変更の枠組みを広げる
  ,**** パッケージリポジトリにないパッケージを使用出来るようにする
  ,***** 自身のパッケージリポジトリを持つ
  ,****** パッケージングのための自動化をする
  ,**** モジュールを追加できる


  ,**[#lightsalmon] 再現性とポータビリティを実現する

  ,*** 設定をパブリックリポジトリにアップロードする
  ,**** 機密情報も暗号化をしアップロードする
  ,***** 自動で複合する

  ,*** 異なるOS、アーキテクチャでも動作するようにする
  ,**** 宣言的なディスク構成を行う
  ,**** 設定を共通化できるものとそうで無いもので分割しておく
  ,**** 共通化のために一部で不足している設定を追加で行なえるようにする
  ,**** 鍵を共有する
  ,***** 素早く共有できるようにする
  ,***** 安全に保管出来るようにする
  ,**** 情報をクラウドにアップロードしておく
  ,***** クラウドの構成を宣言的に記述出来るようにする
  ,**** キーボードの差を吸収できるようにする
  ,**** 異なる環境で設定したものをmergeできるようにする
  ,**** 個々のアプリの要求を明確にしておく


  ,**[#lightgreen] 信頼性の確保

  ,*** 問題が起った時にロールバック出来るようにする
  ,**** Gitでcheckout出来るようにする
  ,**** Nixでシステムを管理する

  ,*** 不具合が起こらないようにする 
  ,**** LSPやLinterを導入しておく
  ,**** パスを補完時に存在するかどうかを確認出来るようにする
  ,**** 副作用を排除する
  ,***** /varや/tmpをクリーンに保つ
  ,***** ホームディレクトリをクリーンに保つ
  ,****** XDG base directoryに出来るだけ従う
  ,******* 不必要なdotfilesが無いか確認をする
  ,****** リポジトリを管理する
  ,**** パッケージのversionの更新で環境が壊れないようにする
  ,***** 小まめに更新をする
  ,****** 自動で更新するようにする 
  ,******* 更新時にCIをする

  ,*** 不具合の発見をする
  ,**** CI/CDによる事前ビルド
  ,**** commit前にcheckを行なう
  ,*** 不具合の原因を特定する
  ,**** Gitで差分を管理する
  ,***** 適切な粒度でcommitを行なう
  ,***** commitメッセージの規則を決める
  ,**** AIに確認をしてもらう
  ,***** ディレクトリを読ませる

  ,*** 不具合の原因を解決する
  ,**** パッケージリポジトリで壊れた場合も自分で修正できるようにする
  ,***** Issueを立てれるようにする
  ,***** 自分のパッケージリポジトリを使用する
  ,****** CIでビルドとテストを行なう


  ,**[#plum] 進化と知識の管理

  ,*** 情報収集をする
  ,**** 使用アプリの更新などを通知する
  ,**** ベストプラクティスを調査する
  ,**** 新規ツールの利用可能性を調査する

  ,*** 計画を改善し、タスクを管理をする
  ,**** 各アプリで実現したいことの要求定義をする
  ,***** 改善案やアイデアの課題管理をする
  ,**** 蓄積された知見をドキュメント化する
  ,***  設計と知見を記録し、道筋を見失わないようにする
  ,**** 管理方法を明確にする
  ,**** 設計思想を明確にする 
  ,**** ゴールモデルを文書化する
  ,**** 要求を明確にする

  @endmindmap
#+end_src

#+RESULTS:
[[file:ゴールモデル.png]]

* ゴールの説明

** 継続的に進化する、再現可能な開発環境の実現
- 目的、意図:
   このリポジトリが目指す究極の目的は、ツールや環境の制約から開発者を開放し、本来の創造的な作業に完全集中できる状態を実現することです。環境構築の煩わしさ、OS間の差異、設定変更に伴うリスクといった「摩擦」を極限までゼロに近づけます。このリポジトリは、単なる設定のバックアップではなく、所有者と共に成長し、常に最適な状況へと適応し続ける*「生きた作業基盤」*として設計されています。
- 達成基準:
  1. 迅速な再現性:
    新規ホストのセットアップが、リポジトリのcloneから30分以内に完了する。
  2. 完全な可搬性:
     LinuxとMacOSの間で、作業感に差異が感じられない。
  3. 容易な継続サイクル:
     - 速度
        キーマップ変更のような軽微な設定変更から、task switch 等によるシステムへの適用完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - モジュール性:
        新しいアプリケーションの追加や設定変更が、他の部分に影響を与えることなく、モジュールとして自己完結した形で追加、修正をできる。
  4. 進化と知識の管理:
     主要な設計思想や各ゴールの達成基準がドキュメントとして明記されており、未来の自分が参照した際に、なぜその設計になっているのか迅速に理解できる。
- 現在の状況:
  - 再現性
     MacOSではある程度の速さはでセットアップを出来る気もするが、GUIでの操作などのドキュメント化が不足している。Linuxではしばらくの間OSの再インストールを行っていないためどの程度の再現性があるか不明。
  - 可搬性
     幾つかの設定では共通化できているが、出来ていないものもある。
  - 継続サイクル
     モジュール化はファイル分けなどはうまくできていそうだが、内容の重複などはありそう。
  - ドキュメンテーション
     現状の把握はAIに吐かせたものをそのまま使用しているし、ゴールモデルについても文書化はこれから。org-roamとの連携も課題。

*** 変更の容易性と拡張性を確保する
- 目的、意図:
   日々の情報収集や作業の中で発生する無数の「こうしたい」という思いつきを、集中力を途絶えさせることなく、迅速かつ柔軟にシステムに反映できるようにする。変更のコストを下げることで、アグレッシブな改善とシステムの進化を促進する。
- 達成基準:
  1. 効率性:
     - 速度:
        キーマップ変更のような軽微な設定変更から、適応完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - 自動化
        繰り返し行なうビルドやテストなどのタスクは自動化しておく。
  2. 拡張性:
     - モジュール性:
        新規アプリケーションの追加はapplications/ディレクトリ以下に自己完結したモジュールとして追加をすることができ、コアのロジックの追加を必要としない。
     - 依存関係:
        nixpkgsにないパッケージも、自前のパッケージリポジトリを通じて、容易に追加、利用が出来る。
- 現状と課題
  - 現状
     軽微な変更は素早く行なうことができる。
  - 課題
     Emacsのような大規模なパッケージのビルドがボトルネックとなり、軽微な変更であっても達成基準を(1分以内)を阻害するケースがある。ビルドプロセスの更なる最適化が必要。
  - 課題
    パッケージの追加方法が場当たり的になっており不十分なところも多い。ドキュメント化する必要がある。


**** 開発サイクルを高速化する
- 目的、意図:
   設定変更の度に生じる「待ち時間」と「煩雑な手作業」を徹底的に排除し、開発者の集中力を持続させることを目的とする。
    
- 達成基準:
  1. 高速化:
     - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。

     - emacsのビルドを5分以内に完了する。
        
  2. 自動化:
     設定変更は、関連するファイルの編集するだけでよく、フォーマット、チェック、適用といった一連の作業は、自動化されたツールによって実行される。
- 現状と課題:
  - 現状
     タスクランナーを使用して短かいコマンドで日々の作業を行うことができる
     
  - 課題
     自宅のデスクトップはマシンパワーが弱く、ビルドするのに時間が掛かる。

  - 課題
     pre-commitがどの程度の範囲の活動をしているか把握していない。

  - 課題
     CIがうまく動作しない

***** 素早いビルドが行なえる
- 目的、意図:
   設定変更の際に必ず生じるビルドの時間を短かくすることで、「待ち時間」の削減をし、思考のフローを維持する。
- 達成基準:
  - 時間的目標
    - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - 効率的目標
    - 一度ビルドしたderivationはどのホストであっても再ビルドされることはない。
- 現状と課題:
  - 分散ビルド
     行われていない
  - キャッシュ
    - 現状
       pullは行なわれている
    - 課題
      - pushは行われていない
      - pullの確認ができていない
****** 分散ビルドが行なえる
- 目的、意図:
   研究室の高性能なPCをビルドに用いることで、ビルドの時間を短縮し思考のフローを維持する。
- 達成基準:
  - 時間目標
    - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - リソース活用目標
    - 自宅のPCとラップトップでは自身を含めて3台のマシンでビルドを行なう。
    - 研究室のマシンでは自身を含めて2台のマシンでビルドを行なう。
- 現況と課題:
  - 現状
    - Nixによる分散ビルドの設定はできている。
    - ryukへのネットワーク設定はcloudflare経由で接続可能。
  - 課題
    - 分散ビルドを行なうにはrootユーザーでのssh接続が必要だが、現在はuserでの鍵交換のみ行っている。このため分散ビルドが機能していない。
    - remのマシンではCloudflareが正しく設定されていない。
******* root userで研究室のPCに接続できる
- 目的、意図:
   分散ビルドを実現するため、ローカルのNixデーモン（root）からリモートビルダーに対してビルドタスクを委任できる、安全な権限移譲の仕組みを確立する。
- 達成基準:
   ローカルのrootユーザーが、リモートマシン上の非特権ビルドユーザーへ、鍵認証を用いてパスワードなしでSSH接続できる。
- 現状と課題
  - 現状
    - Cloudflareによって研究室のPCはSSH接続可能な状態にある。
  - 課題
    - rootのssh鍵を共有していない。どのように管理するかも迷っている。
    - 手作業で行ったものはできたが、Nixで設定したい。
    - ラボのマシン同士でも交換する必要がある。
***** 作業の自動化ができる

****** 反映させたいホストにまとめて反映できる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 機密情報も一括で管理を可能にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** タスクランナーで普段行うタスクを素早く実行出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** pre-commitでcommit前にlinterやformatterを適用する
****** CIでビルドの確認をする

**** 変更の枠組みを広げる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージリポジトリにないパッケージを使用出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自身のパッケージリポジトリを持つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* パッケージングのための自動化をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** モジュールを追加できる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 再現性とポータビリティを実現する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 設定をパブリックリポジトリにアップロードする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 機密情報も暗号化をしアップロードする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自動で複合する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 異なるOS、アーキテクチャでも動作するようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 宣言的なディスク構成を行う
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設定を共通化できるものとそうで無いもので分割しておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 共通化のために一部で不足している設定を追加で行なえるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 鍵を共有する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 素早く共有できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 安全に保管出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 情報をクラウドにアップロードしておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** クラウドの構成を宣言的に記述出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** キーボードの差を吸収できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 異なる環境で設定したものをmergeできるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 個々のアプリの要求を明確にしておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 信頼性の確保
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 問題が起った時にロールバック出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Gitでcheckout出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Nixでシステムを管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合が起こらないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** LSPやLinterを導入しておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パスを補完時に存在するかどうかを確認出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 副作用を排除する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** /varや/tmpをクリーンに保つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** ホームディレクトリをクリーンに保つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* XDG base directoryに出来るだけ従う
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******** 不必要なdotfilesが無いか確認をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* リポジトリを管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージのversionの更新で環境が壊れないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 小まめに更新をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* 自動で更新するようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******** 更新時にCIをする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の発見をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** CI/CDによる事前ビルド
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** commit前にcheckを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の原因を特定する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Gitで差分を管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 適切な粒度でcommitを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** commitメッセージの規則を決める
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** AIに確認をしてもらう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** ディレクトリを読ませる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の原因を解決する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージリポジトリで壊れた場合も自分で修正できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** Issueを立てれるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自分のパッケージリポジトリを使用する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* CIでビルドとテストを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 進化と知識の管理
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 情報収集をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 使用アプリの更新などを通知する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** ベストプラクティスを調査する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 新規ツールの利用可能性を調査する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 計画を改善し、タスクを管理をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 各アプリで実現したいことの要求定義をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 改善案やアイデアの課題管理をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 蓄積された知見をドキュメント化する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設計と知見を記録し、道筋を見失わないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 管理方法を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設計思想を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** ゴールモデルを文書化する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 要求を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:
   
