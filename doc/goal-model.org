* nix-shell
#+name: tmp-shell
#+BEGIN_SRC nix :noweb yes
  { pkgs ? import <nixpkgs> {} }:
  pkgs.mkShell { buildInputs = with pkgs; [ plantuml jdk]; }
  #+END_SRC
#+begin_src elisp :nix-shell tmp-shell :results output
  (setq org-plantuml-jar-path "/nix/store/03nh9m73gwwj477yralnsw70igwswfi5-plantuml-1.2025.3/lib/plantuml.jar")
#+end_src
* ゴールモデル

** 色付けの意味
ゴールモデルの各ノードは、その実現形態や責任主体に応じて色分けされています：

- **Yellow（黄色）**: システムによって実現することが期待されるゴール
  - 主にソフトウェアやツールによって自動化・効率化される項目
  - 例: 分散ビルド、キャッシュ利用、CI/CD、pre-commit等

- **HotPink（ホットピンク）**: システムによって実現することが期待されるゴールの中で未達成のもの
  - Yellowと同様にシステムで実現されるべき項目だが、まだ実装されていない
  - 優先的に取り組むべき自動化・効率化の対象
  - 例: タスクランナーの導入、pre-commitの設定、宣言的ディスク構成等

- **Gainsboro（灰色）**: システム以外で実現することが期待されるゴール
  - 主に人間の判断や物理的な作業が必要な項目
  - 例: SSDの増設、適切なcommit粒度の判断、Issue作成等

- **無色**: 複合的な性質を持つゴールまたは分類が明確でないゴール
  - システムと人間の協調が必要な項目や、より抽象的な概念

この色分けにより、自動化の対象となるゴールと人間の判断・作業が必要なゴールを明確に区別し、効率的な開発環境の構築を支援します。

#+begin_src plantuml :nix-shell tmp-shell  :file ゴールモデル.png
  @startmindmap
  !theme materia

  ,* 継続的に進化する、再現可能な開発環境の実現

  ,**[#lightblue] 変更の容易性と拡張性を確保する

  ,*** 開発サイクルを高速化する
  ,**** 素早いビルドが行なえる
  ,*****[#Yellow] 分散ビルドをする
  ,*****[#Yellow] キャッシュを利用する
  ,*****[#Gainsboro] 自宅のデスクトップにSSDを増設する
  ,**** 反復作業を効率化する
  ,*****[#Yellow] 設定変更の影響範囲を意図した範囲に限定できる
  ,*****[#Yellow] 機密情報も一括で管理を可能にする
  ,*****[#Yellow] 普段行うタスクを素早く実行出来るようにする
  ,*****[#Yellow] pre-commitでcommit前にlinterやformatterを適用する
  ,*****[#Yellow] CIでビルドの確認をする
  ,*****[#Yellow] Garbage Collectionを自動化する
  ,*****[#Yellow] flakeのインプットの更新を自動化する
  ,*****[#HotPink] 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化

  ,*** 変更の枠組みを広げる
  ,**** パッケージリポジトリにないパッケージを使用出来るようにする
  ,*****[#Gainsboro] 自身のパッケージリポジトリを持つ
  ,****** パッケージングのための自動化をする
  ,****[#Yellow] モジュール化による設定の再利用性と保守性の向上


  ,**[#lightsalmon] 再現性とポータビリティを実現する

  ,*** 再現性の確保

  ,**** 宣言的な管理
  ,*****[#Yellow] 設定のコード化
  ,*****[#Yellow] 宣言的なインフラ管理
  ,*****[#HotPink] 宣言的なディスク構成

  ,**** 安全な情報管理
  ,*****[#Yellow] SOPSによる機密情報の暗号化と自動復号
  ,*****[#Yellow] 鍵の安全かつ迅速な共有

  ,*** ポータビリティの実現

  ,**** 環境差の吸収

  ,*****[#Yellow] クロスOS/Arch対応
  ,*****[#Yellow] 不足している機能の追加システム
  ,*****[#HotPink] キーボード等のデバイス差の吸収

  ,**** 柔軟な設定構造
  ,*****[#Yellow] 設定の共通化と分割
  ,*****[#Yellow] 異なる環境からの設定のマージ

  ,**[#lightgreen] 信頼性の確保

  ,*** 問題が起った時にロールバック出来るようにする
  ,****[#Yellow] Gitでcheckout出来るようにする
  ,****[#Yellow] Nixでシステムを管理する

  ,*** 不具合が起こらないようにする
  ,****[#HotPink] LSPやLinterを導入しておく
  ,****[#HotPink] パスを補完時に存在するかどうかを確認出来るようにする
  ,**** 副作用を排除する
  ,*****[#HotPink] /varや/tmpをクリーンに保つ
  ,***** ホームディレクトリをクリーンに保つ
  ,****** XDG base directoryに出来るだけ従う
  ,*******[#HotPink] 不必要なdotfilesが無いか確認をする
  ,******[#Gainsboro] リポジトリを管理する
  ,**** パッケージのversionの更新で環境が壊れないようにする
  ,***** 小まめに更新する
  ,******[#Yellow] 自動で更新するようにする
  ,******* 更新時にCIをする

  ,*** 不具合の発見をする
  ,****[#Yellow] CI/CDによる事前ビルド
  ,****[#Yellow] commit前にcheckを行なう
  ,*** 不具合の原因を特定する
  ,**** Gitで差分を管理する
  ,*****[#Gainsboro] 適切な粒度でcommitを行なう
  ,*****[#Yellow] commitメッセージの規則を決める
  ,**** AIに確認をしてもらう
  ,*****[#HotPink] ディレクトリを読ませる

  ,*** 不具合の原因を解決する
  ,**** パッケージリポジトリで壊れた場合も自分で修正できるようにする
  ,*****[#Gainsboro] Issueを立てれるようにする
  ,*****[#Gainsboro] 自分のパッケージリポジトリを使用する
  ,****** CIでビルドとテストを行なう


  ,**[#plum] 進化と知識の管理

  ,***[#Gainsboro] 情報収集をする

  ,*** 次のアクションを決定し、相談できる状態にする
  ,****[#Gainsboro] 使用アプリの更新を通知する
  ,****[#HotPink] 問題点、改善案、タスク、アイディアを管理する

  ,*** 設計と知見を記録し、道筋を見失わないようにする
  ,****[#HotPink] 要求を文書化する
  ,****[#HotPink] 設計を文書化する
  ,****[#HotPink] 決定の背景を整理し、立ち戻って更新できるようにする

  @endmindmap
#+end_src

#+RESULTS:
[[file:ゴールモデル.png]]

* ゴールの説明

** 継続的に進化する、再現可能な開発環境の実現
- 目的、意図:
   このリポジトリが目指す究極の目的は、ツールや環境の制約から開発者を開放し、本来の創造的な作業に完全集中できる状態を実現することです。環境構築の煩わしさ、OS間の差異、設定変更に伴うリスクといった「摩擦」を極限までゼロに近づけます。このリポジトリは、単なる設定のバックアップではなく、所有者と共に成長し、常に最適な状況へと適応し続ける*「生きた作業基盤」*として設計されています。
- 達成基準:
  1. 迅速な再現性:
    新規ホストのセットアップが、リポジトリのcloneから30分以内に完了する。
  2. 完全な可搬性:
     LinuxとMacOSの間で、作業感に差異が感じられない。
  3. 容易な継続サイクル:
     - 速度
        キーマップ変更のような軽微な設定変更から、nh switch 等によるシステムへの適用完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - モジュール性:
        新しいアプリケーションの追加や設定変更が、他の部分に影響を与えることなく、モジュールとして自己完結した形で追加、修正をできる。
  4. 進化と知識の管理:
     主要な設計思想や各ゴールの達成基準がドキュメントとして明記されており、未来の自分が参照した際に、なぜその設計になっているのか迅速に理解できる。
- 現在の状況:
  - 再現性
     MacOSではある程度の速さはでセットアップを出来る気もするが、GUIでの操作などのドキュメント化が不足している。Linuxではしばらくの間OSの再インストールを行っていないためどの程度の再現性があるか不明。
  - 可搬性
     幾つかの設定では共通化できているが、出来ていないものもある。
  - 継続サイクル
     モジュール化はファイル分けなどはうまくできていそうだが、内容の重複などはありそう。
  - ドキュメンテーション
     現状の把握はAIに吐かせたものをそのまま使用しているし、ゴールモデルについても文書化はこれから。org-roamとの連携も課題。

*** 変更の容易性と拡張性を確保する
- 目的、意図:
   日々の情報収集や作業の中で発生する無数の「こうしたい」という思いつきを、集中力を途絶えさせることなく、迅速かつ柔軟にシステムに反映できるようにする。変更のコストを下げることで、アグレッシブな改善とシステムの進化を促進する。
- 達成基準:
  1. 効率性:
     - 速度:
        キーマップ変更のような軽微な設定変更から、適応完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - 自動化
        繰り返し行なうビルドやテストなどのタスクは自動化しておく。
  2. 拡張性:
     - モジュール性:
        新規アプリケーションの追加はapplications/ディレクトリ以下に自己完結したモジュールとして追加をすることができ、コアのロジックの追加を必要としない。
     - 依存関係:
        nixpkgsにないパッケージも、自前のパッケージリポジトリを通じて、容易に追加、利用が出来る。
- 現状と課題
  - 現状
     軽微な変更は素早く行なうことができる。
  - 課題
     Emacsのような大規模なパッケージのビルドがボトルネックとなり、軽微な変更であっても達成基準を(1分以内)を阻害するケースがある。ビルドプロセスの更なる最適化が必要。
  - 課題
    パッケージの追加方法が場当たり的になっており不十分なところも多い。ドキュメント化する必要がある。


**** 開発サイクルを高速化する
- 目的、意図:
   設定変更の度に生じる「待ち時間」と「煩雑な手作業」を徹底的に排除し、開発者の集中力を持続させることを目的とする。

- 達成基準:
  1. 高速化:
     - キーマップ変更のような軽微な設定変更から nh switchによる適用完了までが1分以内に完了する。

     - emacsのビルドを5分以内に完了する。

  2. 自動化:
     設定変更は、関連するファイルの編集するだけでよく、フォーマット、チェック、適用といった一連の作業は、自動化されたツールによって実行される。
- 現状と課題:
  - 現状
     nhを使用して短かいコマンドで日々の作業を行うことができる
  - 現状
     CIは動作している。
  - 現状
     pre-commitによりcommit前にフォーマットとリントが実行される。


***** 素早いビルドが行なえる
- 目的、意図:
   設定変更の際に必ず生じるビルドの時間を短かくすることで、「待ち時間」の削減をし、思考のフローを維持する。
- 達成基準:
  - 時間的目標
    - キーマップ変更のような軽微な設定変更から、nh switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - 効率的目標
    - 一度ビルドしたderivationはどのホストであっても再ビルドされることはない。
- 現状と課題:
  - 達成状況: 達成
  - 現状
    - 分散ビルド
       適切に動作している。
    - キャッシュ
       適切に動作している。
****** 分散ビルドが行なえる
- 目的、意図:
   研究室の高性能なPCをビルドに用いることで、ビルドの時間を短縮し思考のフローを維持する。
- agent
   分散ビルドシステム
- 達成基準:
  - 時間目標
    - キーマップ変更のような軽微な設定変更から、nh switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - リソース活用目標
    - 自宅のPCとラップトップでは自身を含めて3台のマシンでビルドを行なう。
    - 研究室のマシンでは自身を含めて2台のマシンでビルドを行なう。
- 現況と課題:
  - 達成状況: 達成
  - 現状
    - 全ての分散ビルドを利用できるマシンから全ての接続できるサーバーを利用して分散ビルドを行なうことができる。
    - 全ての分散ビルドを利用できるマシンで分散ビルドに使用するサーバーに接続をすることができる。


****** キャッシュを利用する
- 目的、意図:
   Cachixのバイナリキャッシュを利用することで、ビルド済みのパッケージを再利用し、ビルド時間を短縮する。特に、分散ビルドが利用できない環境(MacBook)での開発サイクルの高速化を目指す。
- agent
   cachix
- 達成基準：
  1. キャッシュヒット率:
     ローカルマシンでのビルド時、変更されたderivation以外の全てのderivationがキャッシュから取得（pull）される。
  2. ビルド時間短縮:
     キャッシュが有効な状態でのビルド時間は、キャッシュがない場合と比較して、体感で半分以下になる（目標: 5分以内）。
- 現状と課題
  - ステータス
     達成済み
  - 現状
    - pullはnix.confにsubstitutersとtrusted-public-keysを設定してあるのでできていそう。
    - pushはGitHub Actionsを経由して行なえている。
****** 自宅のデスクトップにSSDを増設する[期待」
***** 反復作業を効率化する
- 目的、意図:
   設定変更の際に付随して発生する、フォーマットやテスト、適用といった反復的な作業を自動化することで、開発者が本来の目的である「本質的な設定内容の検討」のみに集中できる状況を作り出す。
- 達成基準:
   以下の作業が、手動でのコマンドを必要とせずに、適切なタイミングで自動的に実行される。
  1. コード品質の維持:
     ファイル保存時やcommit時に、フォーマットと静的解析が自動で実行される。
  2. テストの実行:
     push時に、システムのビルドテストが自動で実行される。
  3. システムの適用:
     nhからの単一コマンドでホストを左右されず、ビルドから適用まで一気通貫で実行される。
  4. 定期メンテナンス:
     Nixストアのガベージコレクションやパッケージの更新などの保守作業がスケジュールに基づいて自動で実行される。
- 現状と課題:
  1. コード品質の維持について:
     - 達成状況: 部分的に達成
     - 課題
        pre-commitの設定を把握していない。
  2. テストの実行について:
     - 達成状況: 達成
     - 現状
        CIでビルドの確認ができる。
     - 現状
        nur-packagesのCIも動作している。
  3. システムの適用について:
     - 達成状況: 部分的に達成
     - 現状
        適切なモジュール化ができているため反映させたいホストにまとめて反映ができる。
     - 現状
        機密情報を別途で手作業で管理する必要がない。
     - 現状
        nhで普段行うタスクを素早く、情報を確認しながら実行できる。
  4. 定期メンテナンスについて:
     - 達成状況: 達成
     - 現状
        Garbage Collectを自動で行っている。
     - 現状
        Renovateがflake.nixの依存関係の更新を行っている。


****** 設定変更の影響範囲を意図した範囲に限定できる
- 目的、意図:
   設定変更を行う際に、意図しない副作用や予期しない影響を他のシステム部分に与えることを防ぐ。モジュール化された設定構造により、変更の影響範囲を明確に制御し、安全で予測可能な設定変更を実現する。
- 達成基準:
  - 設定変更時に影響を受ける範囲が事前に明確
  - ホスト固有の設定変更が他のホストに影響しない
  - アプリケーション固有の設定変更が他のアプリケーションに影響しない
  - テスト環境での変更検証が可能
- 現在の状況:
  - 達成状況: 達成
  - 現状: モジュール化された構造により、変更の影響範囲は適切に制御されている
  - 現状: applications/、homes/、systems/の分離により影響範囲が明確

****** 機密情報も一括で管理を可能にする
- 目的、意図:
   API Key、パスワード、証明書などの機密情報を分散して管理することによる漏洩リスクと管理負荷を軽減する。SOPSによる暗号化を活用して、機密情報も含めて全ての設定を一元的にコード管理し、安全性と利便性を両立する。
- 達成基準:
  - 全ての機密情報がSOPSで暗号化されてリポジトリに保存される
  - 機密情報の追加・変更・削除が統一された手順で実行できる
  - ビルド時の自動復号により、手動での機密情報入力が不要
  - 機密情報へのアクセス制御が適切に管理される
- 現在の状況:
  - 達成状況: 達成
  - 現状: SOPSによる機密情報の暗号化と自動復号が実装済み
  - 現状: secrets/default.yamlで一元管理されている

****** 普段行うタスクを素早く実行出来るようにする
- 目的、意図:
   日常的に実行するビルド、適用、テスト等のタスクを短いコマンドで実行できるようにし、作業効率を向上させる。複雑なコマンドラインを覚える必要をなくし、タイプミスによるエラーを防止する。
- 達成基準:
  - 頻繁に使用するタスクが短いコマンド(nh os switchなど)で実行可能
  - タスクの実行時間と結果が適切に表示される
- 現在の状況:
  - 達成状況: 達成
  - 現状: nhによって情報を多く取得しながら、短いコマンドでswitchを実行することができる。

****** pre-commitによるコード品質の自動化
- *目的*: コミット前の自動フォーマットと静的解析により、コード品質と一貫性を担保する。
- *ステータス*: 達成済み
- *実装*: ~treefmt-nix~ と ~git-hooks.nix~ により、コミット時に各種チェッカーを自動実行。
- *対応チェッカー*:
  | 言語/形式 | フォーマッター | リンター |
  |-----------|---------------|----------|
  | Nix | nixfmt | nil |
  | Nushell | - | - |
  | Lua | stylua | luacheck |
  | Terraform | terraform fmt | tflint + terraform validate |
  | Python | ruff format | ruff check |
  | Shell | shfmt | shellcheck |
  | JSON | biome | biome |
  | YAML | yamlfmt | yamllint |
  | TOML | taplo | check-toml |
- *追加フック*:
  - ~detect-private-keys~: 機密情報の漏洩防止
  - ~end-of-file-fixer~: ファイル末尾の改行統一
  - ~trim-trailing-whitespace~: 行末の空白削除
  - ~fix-byte-order-marker~: BOM削除
  - ~actionlint~: GitHub Actions構文チェック
  - ~typos~: typoを検出
****** CIでビルドの確認をする
- 目的、意図:
   プルリクエストやpush前にビルドの成功を自動で検証し、破綻した設定がメインブランチに混入することを防ぐ。複数プラットフォームでのビルド検証により、環境差による問題を早期発見する。
- 達成基準:
  - 全てのプルリクエストでビルドテストが自動実行される
  - Linux（NixOS）とmacOS（Darwin）の両方でビルドが検証される
  - ビルド失敗時にCIが適切にfailし、詳細なエラー情報が提供される
  - Cachixとの連携によりビルド時間が最適化される
- 現在の状況:
  - 達成状況: 達成
  - 現状: GitHub Actionsによる包括的なCIが実装済み
  - 現状: 複数プラットフォームでのビルド検証が動作中
****** Garbage Collectionを自動化する
- 目的、意図
   Nixは大量に容量を必要とし、すぐに容量(特に/boot)を埋め尽してしまう。この問題が発生する度に自身でGarbage Collectをするのは作業効率を低下させるので、自動でGarbage Collectを実行するようにする。
- 達成条件
  - 実行条件:
     どのホストでも週に一度GCを行う。
  - 環境条件:
     容量の問題によって設定変更の失敗が起きない。
- 現状と課題
  - 達成状況 達成
****** flakeのインプットの更新を自動化する
- 目的、意図:
   nixpkgsやその他の依存関係の更新を自動化し、常に最新のセキュリティパッチと機能を利用できるようにする。手動更新の負荷を軽減し、更新忘れによるセキュリティリスクを防止する。
- 達成基準:
  - 定期的（週次）にflake.lockの更新が自動実行される
  - 更新時に自動でプルリクエストが作成される
  - CIによる自動テスト後、問題がなければ自動マージされる
  - 重要な更新については手動確認が求められる
- 現在の状況:
  - 達成状況: 達成
  - 現状: Renovateによる自動更新システムが稼働中
  - 現状: CI連携により安全な自動更新が実現されている
****** 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
- 目的、意図:
   新しいツールを導入したい際に、nixpkgsでの利用可能性を迅速に確認し、導入可否の判断を素早く行えるようにする。検索時間の短縮により、ツール評価のサイクルを高速化する。
- 達成基準:
  - パッケージ検索が数秒以内で完了する
  - 検索結果に利用可能なバージョン情報が含まれる
  - 検索結果から直接インストール方法が確認できる
  - オフライン検索も可能
- 現在の状況:
  - 達成状況: 達成
  - 現状: nhコマンドによる高速パッケージ検索が利用可能
  - 現状: nix search nixpkgsとの組み合わせで包括的な検索が実現
**** 変更の枠組みを広げる
- 目的、意図:
   既存のパッケージリポジトリやモジュールシステムの制約を超えて、独自の要件に対応できる拡張性を確保する。カスタムパッケージやモジュールの作成により、どのような要求にも柔軟に対応できる基盤を構築する。
- 達成基準:
  - nixpkgsにないパッケージも独自にパッケージ化して利用可能
  - 標準モジュールでカバーできない設定も独自モジュールで対応可能
  - 新規技術やツールの導入が迅速に行える
  - パッケージングとモジュール作成の自動化による効率化
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesによる独自パッケージ管理が実装済み
  - 現状: modules/構造による独自モジュール作成が可能

***** パッケージリポジトリにないパッケージを使用出来るようにする
- 目的、意図:
   nixpkgsに含まれていない特殊なツールや最新版ソフトウェアも、システム管理の対象として統一的に扱えるようにする。Nixの宣言的管理の恩恵を、サードパーティ製品についても享受する。
- 達成基準:
  - nixpkgsにないパッケージも.nixファイルで定義・管理できる
  - 独自パッケージもCIによる品質管理の対象となる
  - バイナリキャッシュの恩恵を独自パッケージでも受けられる
  - パッケージの更新管理が自動化される
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesリポジトリによる独自パッケージ管理が実装済み
  - 現状: overlaysを通じてシステムに統合される仕組みが構築済み

****** 自身のパッケージリポジトリを持つ
- 目的、意図:
   upstream（nixpkgs）の問題や更新遅延に影響されない独立したパッケージ供給体制を構築する。緊急のパッチ適用や独自改変が必要な場合にも、迅速に対応できるようにする。
- 達成基準:
  - 独自パッケージリポジトリが稼働し、継続的に維持される
  - パッケージの追加・更新・削除が標準化された手順で実行できる
  - CI/CDによる品質管理が独自パッケージにも適用される
  - nixpkgsとの統合が適切に管理される
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesがGitHubで公開・運用されている
  - 現状: GitHub ActionsによるCI/CDが実装済み

******* パッケージングのための自動化をする
- 目的、意図:
   新しいソフトウェアのパッケージ化作業を効率化し、手作業によるミスを削減する。テンプレートや自動生成ツールにより、パッケージ定義の作成時間を短縮し、品質の一貫性を保つ。
- 達成基準:
  - パッケージ定義のテンプレート生成が自動化される
  - 依存関係の自動解析と記述が可能
  - ビルドとテストの自動実行により品質が保証される
  - パッケージ更新の半自動化が実現される
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的なパッケージング環境は整備済み
  - 課題: テンプレート生成や依存関係解析の自動化が未実装

***** モジュール化による設定の再利用性と保守性の向上
- 目的、意図:
   システムが複雑化する中で、設定の再利用性と可読性を向上させるため、独自のモジュールを定義・追加できる仕組みを構築する。設定の重複をなくし、特定機能の追加・変更・削除が他部分に影響を与えにくい疎結合な構造を確立することが狙い。
- 達成基準:
   /module以下に特定の機能や役割を持つモジュールを新規作製し、参照できる。
- 現況と課題:
  - 現状: 達成
       NixOS、darwin-nix、home-manager、およびそれらの複合についてモジュールを作製できる環境を得た。



*** 再現性とポータビリティを実現する
- 目的、意図:
   環境依存性を排除し、どのマシンでも同一の開発環境を迅速に再現できるシステムを構築する。OSやアーキテクチャの違いを吸収し、設定の可搬性を最大化することで、開発者がハードウェアやプラットフォームの制約から解放される状態を実現する。
- 達成基準:
  1. 再現性の確保:
     - 新規ホストでのセットアップが30分以内に完了
     - 設定のコード化により、手動設定が不要
  2. ポータビリティの実現:
     - LinuxとmacOSの間で作業感に差異が感じられない
     - 環境差の自動吸収とクロスプラットフォーム対応
- 現在の状況:
  - 再現性: NixとHome Managerにより基本的な再現性は確保されているが、一部手動設定が残存
  - ポータビリティ: プラットフォーム間での共通化は進んでいるが、完全な統一は未達成

**** 再現性の確保
- 目的、意図:
   設定の完全なコード化と宣言的管理により、環境の再現性を100%保証する。
- 達成基準:
  - 全設定がコードとして管理され、手動設定が存在しない
  - 機密情報も暗号化して安全に管理される
- 現在の状況:
  - 基本設定はコード化済み、機密情報管理も実装済み

***** 設定のコード化
- 目的、意図:
   全ての設定をNixファイルとして宣言的に記述し、手動設定を排除する。
- 達成基準:
  - システム設定、アプリケーション設定が全てコードで管理される
  - 設定変更は全てGitで追跡可能
- 現在の状況:
  - 達成状況: 達成
  - 現状: Nixによる宣言的システム管理が実装済み

***** 宣言的なインフラ管理
- 目的、意図:
   クラウドインフラもコードとして管理し、再現可能性を確保する。
- 達成基準:
  - Terraformによるインフラのコード化
  - クラウドリソースの宣言的管理
- 現在の状況:
  - 達成状況: 達成
  - 現状: Terraformによるインフラ管理が実装済み

***** 宣言的なディスク構成
- 目的、意図:
   ディスク構成も宣言的に管理し、システム全体の再現性を確保する。
- 達成基準:
  - Diskoによるディスク構成のコード化
  - パーティション設定の自動化
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: Diskoの設定は存在するが、全ホストでの検証は未完了

**** 安全な情報管理
- 目的、意図:
   機密情報も含めて全ての設定情報を安全かつ自動的に管理する。
- 達成基準:
  - SOPSによる暗号化と自動復号
  - 鍵の安全な共有システム
- 現在の状況:
  - 達成状況: 達成
  - 現状: SOPS実装済み

***** SOPSによる機密情報の暗号化と自動復号
- 目的、意図:
   機密情報を暗号化してリポジトリに保存し、必要時に自動復号する。
- 達成基準:
  - 全機密情報がSOPSで暗号化される
  - ビルド時の自動復号が動作する
- 現在の状況:
  - 達成状況: 達成
  - 現状: SOPS暗号化システムが動作中

***** 鍵の安全かつ迅速な共有
- 目的、意図:
   暗号化鍵を安全に管理し、新しいホストへの迅速な展開を可能にする。
- 達成基準:
  - Age鍵の安全な保管と共有
  - 新規ホストでの鍵設定自動化
- 現在の状況:
  - 達成状況: 部分的達成
  - 課題: 鍵の初期配布プロセスが手動

**** ポータビリティの実現
- 目的、意図:
   OS・アーキテクチャの違いを完全に吸収し、統一された開発体験を提供する。
- 達成基準:
  - クロスプラットフォーム対応
  - 環境差の自動吸収
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: Linux/macOS対応済み、細部の差分が残存

***** 環境差の吸収
- 目的、意図:
   プラットフォーム固有の差異を自動的に吸収し、統一された環境を提供する。
- 達成基準:
  - OS間でのアプリケーション動作の統一
  - 不足機能の自動補完
- 現在の状況:
  - 達成状況: 部分的達成

****** クロスOS/Arch対応
- 目的、意図:
   LinuxとmacOS間での完全な互換性を実現する。
- 達成基準:
  - 同一設定ファイルでの両OS対応
  - アーキテクチャ差の自動解決
- 現在の状況:
  - 達成状況: 達成
  - 現状: Nix Flakesによりクロスプラットフォーム対応済み

****** 不足している機能の追加システム
- 目的、意図:
   プラットフォーム固有の不足機能を自動的に補完する。
- 達成基準:
  - 不足パッケージの自動検出と追加
  - プラットフォーム固有設定の自動適用
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な機能補完は実装済み

****** キーボード等のデバイス差の吸収
- 目的、意図:
   異なるキーボードレイアウトやデバイス特性を統一的に管理する。
- 達成基準:
  - 統一されたキーマップ設定
  - デバイス固有差分の自動調整
- 現在の状況:
  - 達成状況: 達成
  - 現状: xremapとkarabinerによる統一キーマップ実装済み

***** 柔軟な設定構造
- 目的、意図:
   設定の共通化と分割を適切に行い、保守性と拡張性を両立する。
- 達成基準:
  - 共通設定とホスト固有設定の適切な分離
  - 設定のマージ機能
- 現在の状況:
  - 達成状況: 達成
  - 現状: モジュール化された設定構造が実装済み

****** 設定の共通化と分割
- 目的、意図:
   共通設定と固有設定を適切に分離し、保守性を向上させる。
- 達成基準:
  - 共通設定の一元管理
  - ホスト固有設定の適切な分離
- 現在の状況:
  - 達成状況: 達成
  - 現状: applications/、homes/、systems/による適切な分割済み

****** 異なる環境からの設定のマージ
- 目的、意図:
   複数環境での設定変更を安全にマージし、統合する。
- 達成基準:
  - Gitによる設定変更の追跡
  - コンフリクトの自動解決
- 現在の状況:
  - 達成状況: 達成
  - 現状: Gitベースの設定管理により実現済み

*** 信頼性の確保
- 目的、意図:
   システムの安定性と信頼性を最大化し、問題発生時の迅速な復旧を可能にする。不具合の予防、早期発見、原因特定、解決のサイクルを自動化し、開発者が安心して作業できる環境を構築する。
- 達成基準:
  1. 問題発生時の迅速なロールバック機能
  2. 不具合の予防と早期発見システム
  3. 問題の原因特定と解決の自動化
- 現在の状況:
  - ロールバック: GitとNixによる基本的なロールバック機能は実装済み
  - 予防: pre-commitやCIによる品質チェックは動作中
  - 原因特定: Gitによる変更追跡は確立済み

**** 問題が起った時にロールバック出来るようにする
- 目的、意図:
   システムに問題が発生した際に、迅速に安定した状態に戻せる仕組みを提供する。
- 達成基準:
  - Gitによる設定のバージョン管理
  - Nixによるシステム状態の原子的切り替え
- 現在の状況:
  - 達成状況: 達成
  - 現状: Git + Nixによるロールバック機能が実装済み

***** Gitでcheckout出来るようにする
- 目的、意図:
   設定の変更履歴を完全に追跡し、任意の時点の状態に戻せるようにする。
- 達成基準:
  - 全設定変更がGitで管理される
  - 任意のコミットへの安全な切り替えが可能
- 現在の状況:
  - 達成状況: 達成
  - 現状: Gitによる完全な設定管理が実装済み

***** Nixでシステムを管理する
- 目的、意図:
   宣言的なシステム管理により、原子的な状態切り替えを実現する。
- 達成基準:
  - システム全体の宣言的管理
  - 原子的なシステム更新とロールバック
- 現在の状況:
  - 達成状況: 達成
  - 現状: NixOSとnix-darwinによるシステム管理が実装済み

**** 不具合が起こらないようにする
- 目的、意図:
   予防的な品質管理により、問題の発生を最小限に抑制する。
- 達成基準:
  - 自動的な品質チェック
  - 副作用の完全な排除
  - 安全な更新プロセス
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な品質チェックは実装済み

***** LSPやLinterを導入しておく
- 目的、意図:
   コード品質を自動的にチェックし、エラーを早期に発見する。
- 達成基準:
  - 全言語でのLSP対応
  - リアルタイムなエラー検出
- 現在の状況:
  - 達成状況: 達成
  - 現状: Emacsでの包括的LSP環境が構築済み

***** パスを補完時に存在するかどうかを確認出来るようにする
- 目的、意図:
   ファイルパスの入力ミスを防止し、存在しないパスへの参照を事前に検出する。
- 達成基準:
  - パス補完時の存在確認
  - 無効なパス参照の警告表示
- 現在の状況:
  - 達成状況: 未達成
  - 現状:以下の最小構成で動作することが確認できた。
     #+begin_src emacs-lisp
       (setq corfu-auto t)
       (setq corfu-auto-delay 0)
       (setq corfu-auto-prefix 1)
       (require 'corfu)
       (global-corfu-mode)


       (add-to-list 'completion-at-point-functions #'cape-file)
       (setq corfu-quit-at-boundary nil)
       (require 'cape)

       (setq lsp-completion-provider :none)
       (defun my-lsp-mode-setup ()
         "LSP利用時に追加の補完設定を行う"
         (add-hook 'completion-at-point-functions #'cape-file nil t))

       (add-hook 'lsp-mode-hook #'my-lsp-mode-setup)
       (require 'lsp)
       (require 'lsp-lens)
       (require 'lsp-modeline)
       (require 'lsp-headerline)

       (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-ts-mode))
       (autoload 'nix-ts-mode "nix-ts-mode" nil t)

       (with-eval-after-load 'nix-ts-mode
         (add-hook 'nix-ts-mode-hook 'lsp)
         )
     #+end_src

***** 副作用を排除する
- 目的、意図:
   システムの一貫性を保つため、予期しない副作用を完全に排除する。
- 達成基準:
  - クリーンなシステム状態の維持
  - XDG Base Directory準拠
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な副作用排除は実装済み

****** /varや/tmpをクリーンに保つ
- 目的、意図:
   一時ディレクトリを常にクリーンな状態に保ち、システムの一貫性を確保する。
- 達成基準:
  - 起動時の一時ディレクトリクリーンアップ
  - 永続化するファイルの明示的指定
- 現在の状況:
  - 達成状況: 達成
  - 現状: impermanenceによるクリーン化が実装済み

****** ホームディレクトリをクリーンに保つ
- 目的、意図:
   ホームディレクトリを整理し、XDG規約に準拠した構造を維持する。
- 達成基準:
  - XDG Base Directory準拠
  - 不要なdotfilesの排除
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的なXDG対応は実装済み

******* XDG base directoryに出来るだけ従う
- 目的、意図:
   標準的なディレクトリ構造に従い、設定ファイルを適切に配置する。
- 達成基準:
  - XDG規約完全準拠
  - 設定ファイルの適切な分類
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 多くのアプリケーションでXDG対応済み

******** 不必要なdotfilesが無いか確認をする
- 目的、意図:
   ホームディレクトリの不要なファイルを定期的に検出し、クリーンな状態を維持する。
- 達成基準:
  - 自動的な不要ファイル検出
  - XDG規約違反の警告
- 現在の状況:
  - 達成状況: 達成
  - 現状: xdg-ninjaによる定期チェックが実装済み

******* リポジトリを管理する
- 目的、意図:
   開発プロジェクトのリポジトリを統一的に管理し、整理された開発環境を維持する。
- 達成基準:
  - 統一されたリポジトリ配置
  - 自動的なクローンと管理
- 現在の状況:
  - 達成状況: 達成
  - 現状: ghqによるリポジトリ管理が実装済み

***** パッケージのversionの更新で環境が壊れないようにする
- 目的、意図:
   パッケージ更新による環境破綻を防止し、安全な更新プロセスを確立する。
- 達成基準:
  - 段階的な更新プロセス
  - 自動的な更新テスト
- 現在の状況:
  - 達成状況: 達成
  - 現状: 自動更新とCIテストが実装済み

****** 小まめに更新をする
- 目的、意図:
   大きな変更による問題を避けるため、小さな更新を頻繁に行う。
- 達成基準:
  - 定期的な自動更新
  - 問題の早期発見
- 現在の状況:
  - 達成状況: 達成
  - 現状: Renovateによる自動更新が動作中

******* 自動で更新するようにする
- 目的、意図:
   手動更新の負荷を排除し、常に最新の安定版を利用できるようにする。
- 達成基準:
  - 自動的な依存関係更新
  - テスト成功後の自動適用
- 現在の状況:
  - 達成状況: 達成
  - 現状: Renovateによる完全自動更新が実装済み

******** 更新時にCIをする
- 目的、意図:
   更新の安全性を事前に検証し、問題のある更新を未然に防ぐ。
- 達成基準:
  - 全更新でのCI実行
  - テスト失敗時の自動却下
- 現在の状況:
  - 達成状況: 達成
  - 現状: GitHub ActionsによるCI検証が実装済み

**** 不具合の発見をする
- 目的、意図:
   問題を早期に発見し、本番環境での障害を防止する。
- 達成基準:
  - 自動的な事前テスト
  - commit前の品質チェック
- 現在の状況:
  - 達成状況: 達成
  - 現状: CI/CDとpre-commitが動作中

***** CI/CDによる事前ビルド
- 目的、意図:
   変更をシステムに適用する前に、ビルドテストで問題を検出する。
- 達成基準:
  - 全プルリクエストでのビルドテスト
  - 失敗時の自動通知
- 現在の状況:
  - 達成状況: 達成
  - 現状: GitHub Actionsによる包括的CIが実装済み

***** commit前にcheckを行なう
- 目的、意図:
   コミット前に自動的な品質チェックを実行し、問題のあるコードの混入を防ぐ。
- 達成基準:
  - 自動フォーマット適用
  - 静的解析の実行
- 現在の状況:
  - 達成状況: 達成
  - 現状: pre-commitフックが動作中

**** 不具合の原因を特定する
- 目的、意図:
   問題発生時に迅速に原因を特定し、効率的な解決を可能にする。
- 達成基準:
  - 完全な変更履歴の追跡
  - AIによる問題分析
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: Git履歴による追跡は確立済み

***** Gitで差分を管理する
- 目的、意図:
   全ての変更を詳細に記録し、問題の原因となった変更を特定できるようにする。
- 達成基準:
  - 適切な粒度でのコミット
  - 統一されたコミットメッセージ
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的なGit管理は確立済み

****** 適切な粒度でcommitを行なう
- 目的、意図:
   変更を論理的な単位で分割し、問題の特定と修正を容易にする。
- 達成基準:
  - 単一責任でのコミット分割
  - 意味のある変更単位
- 現在の状況:
  - 達成状況: 部分的達成
  - 課題: コミット粒度の標準化が不十分

****** commitメッセージの規則を決める
- 目的、意図:
   一貫したコミットメッセージにより、変更の意図を明確に記録する。
- 達成基準:
  - 統一されたメッセージ形式
  - 変更の背景と影響の明記
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的なルールは存在するが、徹底が不十分

***** AIに確認をしてもらう
- 目的、意図:
   AIの分析能力を活用して、人間では見落としがちな問題を発見する。
- 達成基準:
  - コードベースの自動分析
  - 問題箇所の特定と改善提案
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: Claude Codeによる分析が利用可能

****** ディレクトリを読ませる
- 目的、意図:
   AIにコードベース全体を理解させ、包括的な分析と提案を得る。
- 達成基準:
  - プロジェクト全体の構造理解
  - 問題箇所の自動発見
- 現在の状況:
  - 達成状況: 達成
  - 現状: CLAUDE.mdによりAIが適切にコードベースを理解可能

**** 不具合の原因を解決する
- 目的、意図:
   発見された問題を迅速かつ確実に解決し、システムの安定性を回復する。
- 達成基準:
  - 自律的な問題解決能力
  - 外部依存の問題への対応
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な解決手段は整備済み

***** パッケージリポジトリで壊れた場合も自分で修正できるようにする
- 目的、意図:
   上流パッケージの問題に依存せず、自力で問題を解決できる体制を構築する。
- 達成基準:
  - 独自パッケージリポジトリの活用
  - 問題報告と修正の仕組み
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesにより独自パッケージ管理が可能

****** Issueを立てれるようにする
- 目的、意図:
   問題を体系的に報告し、上流への貢献も含めて解決に取り組む。
- 達成基準:
  - 問題の適切な報告
  - 上流コミュニティとの連携
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: GitHub Issuesによる基本的な問題管理は可能

****** 自分のパッケージリポジトリを使用する
- 目的、意図:
   上流の問題に影響されない独自のパッケージ管理システムを活用する。
- 達成基準:
  - 独自パッケージの作成と管理
  - 品質保証のためのテスト
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesが稼働中

******* CIでビルドとテストを行なう
- 目的、意図:
   独自パッケージの品質を保証し、問題のあるパッケージの配布を防ぐ。
- 達成基準:
  - 自動ビルドテスト
  - 品質チェックの実行
- 現在の状況:
  - 達成状況: 達成
  - 現状: nur-packagesでCIによる品質管理が実装済み

*** 進化と知識の管理
- 目的、意図:
   システムの継続的な改善と最適化のためのナレッジマネジメント基盤を構築することを目的とする。技術の進歩、新しいツールの登場、作業フローの変化に対応し、常に最新で最適な開発環境を維持する。また、過去の設計判断、課題解決のプロセス、学習した知見を体系的に記録・管理し、未来の自分や他の開発者が効率的に理解・活用できるようにする。
- 達成基準:
  1. 継続的な情報収集と評価:
     - 新しいベストプラクティスやツールの情報を定期的に収集・評価する仕組みがある
     - 実装したい新機能やツールの利用可能性を迅速に調査できる
  2. 次のアクションを決定し、相談できる状態:
     - 使用しているツールやパッケージの更新情報が自動的に通知される
     - 問題点、改善案、アイディアが適切に記録・管理されている
     - 具体的なアクションプランを策定し、必要に応じて相談できる状態にある
  3. 効果的なタスクと計画管理:
     - 各アプリケーションの要求定義が明確に文書化されている
     - 設計思想とゴールモデルが常に最新の状態で文書化されている
  4. 知識の体系化と継承:
     - 設計判断の根拠と経緯が記録されている
     - 蓄積された知見が検索・参照可能な形で文書化されている
     - 管理方法とワークフローが明確に定義されている
- 現在の状況:
  - 情報収集: 手動で行っており、自動化されていない
  - アクション決定: 更新通知システムが未整備、問題点の管理が体系化されていない
  - 課題管理: GitHub Issuesは設定されているが、体系的な運用はされていない
  - 文書化: ゴールモデルは作成されているが、詳細な設計思想や知見の記録が不足している
  - 管理方法: 明確なワークフローが確立されていない状態

**** 情報収集をする[期待]
- 目的、意図:
   技術の進歩や新しいツールの登場を継続的に追跡し、システムの改善機会を逃さないようにする。
- 達成基準:
  - 使用ツールの更新情報の自動収集
  - 新技術やベストプラクティスの定期的な調査
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な更新通知は設定済み、体系的な情報収集は未整備

***** 使用アプリの更新などを通知する
- 目的、意図:
   使用しているアプリケーションやツールの更新情報を自動的に取得し、適切なタイミングで更新を実施する。
- 達成基準:
  - GitHub Watchやstarによる更新通知
  - 重要な更新の自動検出
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: Renovateによる依存関係更新は自動化済み、手動追跡分が残存

**** 次のアクションを決定し、相談できる状態にする
- 目的、意図:
   収集した情報を基に具体的な改善アクションを決定し、必要に応じて外部と相談できる体制を整える。
- 達成基準:
  - 問題・改善案・タスクの体系的管理
  - 意思決定プロセスの明確化
- 現在の状況:
  - 達成状況: 未達成
  - 現状: GitHub Issuesによる基本的なタスク管理は可能

***** 使用アプリの更新を通知する
- 目的、意図:
   使用ツールの更新情報を効率的に管理し、適切なタイミングでの更新判断を支援する。
- 達成基準:
  - 自動的な更新通知システム
  - 優先度に基づく更新判断
- 現在の状況:
  - 達成状況: 達成
  - 現状: Renovateによる自動更新システムが稼働中

***** 問題点、改善案、タスク、アイディアを管理する
- 目的、意図:
   発見された問題や改善アイデアを体系的に管理し、継続的な改善サイクルを実現する。
- 達成基準:
  - 課題の体系的な分類と管理
  - 進捗状況の可視化
- 現在の状況:
  - 達成状況: 未達成
  - 現状: GitHub Issuesの基本的な活用はあるが、体系的な運用は未整備

**** 設計と知見を記録し、道筋を見失わないようにする
- 目的、意図:
   設計判断の背景や学習した知見を文書化し、長期的な視点でシステムを改善し続けられるようにする。
- 達成基準:
  - 設計思想とゴールモデルの文書化
  - 意思決定の背景記録
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的なドキュメント構造は整備中

***** 要求を文書化する
- 目的、意図:
   システムに対する要求を明確に定義し、開発の方向性を明確にする。
- 達成基準:
  - 機能要求の体系的な整理
  - 要求の優先度付け
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: ゴールモデルによる要求の可視化は進行中

***** 設計を文書化する
- 目的、意図:
   システムの設計思想とアーキテクチャを文書化し、保守性を向上させる。
- 達成基準:
  - アーキテクチャドキュメントの整備
  - 設計判断の根拠記録
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: CLAUDE.mdによる基本的な設計情報は記録済み

***** 決定の背景を整理し、立ち戻って更新できるようにする
- 目的、意図:
   過去の意思決定の背景を記録し、状況変化に応じて適切に見直しができるようにする。
- 達成基準:
  - 決定プロセスの記録
  - 背景情報の体系的な管理
- 現在の状況:
  - 達成状況: 部分的達成
  - 現状: 基本的な記録体制は存在するが、体系化が不十分

* エージェント分析
** エージェント分類

*** 分散ビルドシステム
- 担当ゴール: 1. 分散ビルドをする

*** Nixシステム
- 担当ゴール: 8. Garbage Collectionを自動化する, 22. Nixでシステムを管理する

*** Cachix
- 担当ゴール: 2. キャッシュを利用する

*** SOPS
- 担当ゴール: 4. 機密情報も一括で管理を可能にする

*** nh
- 担当ゴール: 5. 普段行うタスクを素早く実行出来るようにする

*** pre-commit
- 担当ゴール: 6. pre-commitでcommit前にlinterやformatterを適用する, 30. commit前にcheckを行なう

*** GitHub Actions
- 担当ゴール: 7. CIでビルドの確認をする, 29. CI/CDによる事前ビルド

*** renovate bot
- 担当ゴール: 9. flakeのインプットの更新を自動化する, 28. 自動で更新するようにする

*** git
- 担当ゴール: 20. 異なる環境で設定したものをmergeできるようにする, 21. Gitでcheckout出来るようにする

*** terraform
- 担当ゴール: 13. 設定をパブリックリポジトリにアップロードする, 18. クラウドの構成を宣言的に記述出来るようにする

*** disko
- 担当ゴール: 14. 宣言的なディスク構成を行う

*** nur-packages
- 担当ゴール: 11. 自身のパッケージリポジトリを持つ, 16. 共通化のために一部で不足している設定を追加で行なえるようにする

*** ghq
- 担当ゴール: 27. リポジトリを管理する

*** xremap & karabiner
- 担当ゴール: 19. キーボードの差を吸収できるようにする

*** emacs
- 担当ゴール: 23. LSPやLinterを導入しておく, 24. パスを補完時に存在するかどうかを確認出来るようにする

*** impermanence
- 担当ゴール: 25. /varや/tmpをクリーンに保つ

*** xdg-ninja
- 担当ゴール: 26. 不必要なdotfilesが無いか確認をする

*** kaki (リポジトリオーナー)
- 担当ゴール: 17. 鍵を共有する, 31. commitメッセージの規則を決める, 36. 要求を文書化する, 37. 設計を文書化する, 38. 決定の背景を整理し、立ち戻って更新できるようにする

*** Claude Code
- 担当ゴール: 32. ディレクトリを読ませる

*** Github Issue
- 担当ゴール: 35. 問題点、改善案、タスク、アイディアを管理する


** Yellowゴールのエージェント割り当て

以下はゴールモデルでYellowに色付けされたゴールに対するエージェント割り当てです。

*** 1. 分散ビルドをする
- エージェント: 分散ビルドシステム
- インターフェース: リモートサーバー、ビルドログ
- 入力: ビルド対象のderivation、リモートサーバー情報
- 出力: ビルド済みの成果物、ビルドログ

*** 2. キャッシュを利用する
- エージェント: cachix
- インターフェース: GitHub Actions、ビルドログ
- 入力: ビルド済みderivation、キャッシュ要求
- 出力: キャッシュされたバイナリ、キャッシュヒット/ミス情報

*** 3 & 21. 設定の適用範囲を適切に制御できる
- エージェント: Nixモジュールシステム
- インターフェース: ディレクトリ構造
- 入力: 設定変更要求、適用対象の指定
- 出力: 指定された範囲への設定適用結果

*** 4 & 16. 機密情報も一括で管理を可能にする
- エージェント: Sops
- インターフェース: 鍵、ビルドログ
- 入力: 機密情報、暗号化キー
- 出力: 暗号化された機密情報、復号化された設定値

*** 5. 普段行うタスクを素早く実行出来るようにする
- エージェント: nh
- インターフェース: switchコマンド、出力結果
- 入力: タスク名、実行パラメータ
- 出力: タスク実行結果、実行時間

*** 6 & 32. commit前にlinterとformatterを適用する
- エージェント: pre-commit
- インターフェース: formatter、linter、commitログ
- 入力: 変更されたファイル、コミット要求
- 出力: フォーマット済みファイル、リンター結果、コミット可否

*** 7 & 31. CIで設定のビルドの確認をする
- エージェント: GitHub Actions
- インターフェース: cachix、Actionsログ
- 入力: プッシュイベント、ビルド設定
- 出力: ビルド結果、テスト結果、成功/失敗ステータス

*** 8. Garbage Collectionを自動化する
- エージェント: Nixシステム
- インターフェース: /nix/store/、ログ
- 入力: 定期実行スケジュール、削除対象の判定条件
- 出力: 削除されたファイル一覧、解放された容量

*** 9 & 30. flakeのインプットの更新を自動化する
- エージェント: renovate bot
- インターフェース: flake.lock、pull request
- 入力: 更新チェック要求、依存関係情報
- 出力: 更新されたflake.lock、プルリクエスト

*** 10. 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
- エージェント: nh
- インターフェース: nixpkgs、出力結果
- 入力: 検索キーワード、パッケージ名
- 出力: 検索結果、パッケージ情報、インストール方法

*** 11 & 19 & 35. 自身のパッケージリポジトリを持ち、不足パッケージを追加できる
- エージェント: nur-packages
- インターフェース: packages、GitHub Actions
- 入力: パッケージ定義、ビルド設定
- 出力: パッケージ化されたバイナリ、パッケージリポジトリ

*** 12 & 19 & 35. モジュールを追加し、不足設定を補完できる
- エージェント: ディレクトリ構造
- インターフェース: home-manager、NixOS、nix-darwin
- 入力: モジュール定義、設定要求
- 出力: モジュール化された設定、システム統合

*** 13 & 24. Nixでシステムを管理する
- エージェント: Nixシステム
- インターフェース: nix、NixOS、nix-darwin、home-manager
- 入力: システム設定、宣言的設定ファイル
- 出力: 構築されたシステム、ロールバック可能なシステム状態

*** 14 & 18. クラウドの構成を宣言的に管理し、情報をできるだけパブリックに配置する
- エージェント: terraform
- インターフェース: GitHub、Cloudflare、terraform applyの結果
- 入力: インフラ構成定義、クラウドプロバイダー設定
- 出力: デプロイされたインフラストラクチャ、パブリック情報

*** 15. 宣言的なディスク構成を行う
- エージェント: disko
- インターフェース:ssh、ディスクを確認するコマンドの結果
- 入力: ディスク構成定義、パーティション設定
- 出力: 構成されたディスク、ファイルシステム

*** 17. 鍵を共有する
- エージェント: kaki
- インターフェース:GPG、ssh、各ホスト(watari、lawliet、ryuk、rem)
- 入力: 鍵ペア生成要求、共有対象ホスト
- 出力: 共有された鍵、認証設定

*** 18. クロスOS/Archへの対応
- エージェント: Nixシステム
- インターフェース: NixOS、nix-darwin
- 入力: 対象OS/Arch指定、クロスコンパイル設定
- 出力: 各プラットフォーム対応バイナリ、統一設定

*** 20. キーボードの差を吸収できるようにする
- エージェント: xremap & karabiner & qmk
- インターフェース: xremap、karabiner-elements、goku、qmk
- 入力: キーボードレイアウト、キーマップ設定
- 出力: 統一されたキーマップ、デバイス固有の差分吸収

*** 22. 異なる環境で設定したものをmergeできるようにする
- エージェント: git
- インターフェース: git、magit
- 入力: ブランチ情報、変更差分、マージ要求
- 出力: マージされた設定、統合された環境

*** 23. Gitでcheckout出来るようにする
- エージェント: git
- インターフェース git、magit
- 入力: チェックアウト対象コミット、ブランチ情報
- 出力: ロールバックされたシステム状態、バージョン切り替え結果

*** 25. LSPやLinterを導入しておく
- エージェント: emacs
- インターフェース: LSP、flyckeck
- 入力: コードファイル、コード変更イベント
- 出力: コード解析結果、エラー・警告情報、補完候補

*** 26. パスを補完時に存在するかどうかを確認出来るようにする
- エージェント: emacs
- インターフェース: corfu、cape
- 入力: パスの部分入力、ファイルシステム状態
- 出力: パス存在確認結果、補完候補一覧

*** 27. /varや/tmpをクリーンに保つ
- エージェント: impermanence
- インターフェース: NixOS、ssh
- 入力: 永続化するファイルリスト、システム起動イベント
- 出力: クリーンな一時ディレクトリ、永続化されたデータ

*** 28. 不必要なdotfilesが無いか確認をする
- エージェント: xdg-ninja
- インターフェース: home directory
- 入力: ホームディレクトリのスキャン要求、XDG規約情報
- 出力: 不必要なdotfiles一覧、改善推奨事項

*** 29. リポジトリを管理する
- エージェント: ghq
- インターフェース: GitHubリポジトリ
- 入力: リポジトリURL、clone要求、管理コマンド
- 出力: クローンされたリポジトリ、統一されたディレクトリ構造

*** 33. commitメッセージの規則を決める
- エージェント: kaki
- インターフェース: git、magit、Cload Code
- 入力: コミット内容、変更範囲、標準フォーマット
- 出力: 統一されたコミットメッセージ、履歴の統一性

*** 34. ディレクトリを読ませる
- エージェント: Claude Code
- インターフェース: Cloaud.md、jsonの設定ファイル
- 入力: ディレクトリパス、コードベース情報、プロジェクト情報
- 出力: コード解析結果、コード生成、コード改善提案

*** 36. 使用アプリの更新などを通知する
- エージェント: Github
- インターフェース: メール、Github Issue、star
- 入力: リポジトリwatch設定、release情報、starイベント
- 出力: 更新通知、メール、Issue作成

*** 37. 問題点、改善案、タスク、アイディアを管理する
- エージェント: Github Issue
- インターフェース：org-capture、GitHub
- 入力: 問題報告、改善アイデア、タスク要求、プロジェクト情報
- 出力: 管理されたIssue、タスクリスト、進捗状況

*** 38. 要求を文書化する
- エージェント: kaki
- インターフェース: 要求仕様書
- 入力: ビジネス要求、ユーザーストーリー、機能要求
- 出力: 仕様書、要求定義書、ゴールモデル

*** 39. 設計を文書化する
- エージェント: kaki
- インターフェース: 設計仕様書
- 入力: アーキテクチャ設計、システム設計、技術仕様
- 出力: 設計書、アーキテクチャドキュメント、実装ガイド

*** 40. 決定の背景を整理し、立ち戻って更新できるようにする
- エージェント: kaki
- インターフェース: 議事録
- 入力: 決定プロセス、検討内容、決定背景、代替案
- 出力: 決定録、ナレッジドキュメント、将来の参照資料


* 操作の導出

** 1. 分散ビルドの設定をする
- エージェント: NixOS
- インターフェース: リモートサーバー、ビルドログ
- 入力: ビルド対象のderivation、リモートサーバー情報
- 出力: ビルド済みの成果物、ビルドログ
- 事前条件: ビルドサーバーに接続できない。
- 事後条件: ビルドサーバーに接続ができる。
- 手順:
  1. localでパスフレーズのないssh keyを作成する(管理者が行なう必要がある期待)
  2. /root/.ssh/configに設定を作成する
  3. buildMachineの設定をNixに書く
  4. ホスト側で公開鍵の設定をNixで行う

** 2. キャッシュを利用できる設定にする
- エージェント: cachix
- インターフェース: GitHub Actions、ビルドログ
- 入力: ビルド済みderivation、キャッシュ要求
- 出力: キャッシュされたバイナリ、キャッシュヒット/ミス情報
- 事前条件: Nixでビルドを行なう際に自身のマシンでのみ行う設定になっている。
- 事後条件: 他のホストで一度行った設定であれば、ビルドをする際にキャッシュが効く設定になっている。
- 手順:
   1.

** 3 & 21. 設定の適用範囲を適切に制御できる
- エージェント: Nixモジュールシステム
- インターフェース: ディレクトリ構造
- 入力: 設定変更要求、適用対象の指定
- 出力: 指定された範囲への設定適用結果
- 事前条件:
- 事後条件:
- 手順:

** 4 & 16. 機密情報も一括で管理を可能にする
- エージェント: Sops
- インターフェース: 鍵、ビルドログ
- 入力: 機密情報、暗号化キー
- 出力: 暗号化された機密情報、復号化された設定値
- 事前条件:
- 事後条件:
- 手順:

** 5. 普段行うタスクを素早く実行出来るようにする
- エージェント: nh
- インターフェース: switchコマンド、出力結果
- 入力: タスク名、実行パラメータ
- 出力: タスク実行結果、実行時間
- 事前条件:
- 事後条件:
- 手順:

** 6 & 32. commit前にlinterとformatterを適用する
- エージェント: pre-commit
- インターフェース: formatter、linter、commitログ
- 入力: 変更されたファイル、コミット要求
- 出力: フォーマット済みファイル、リンター結果、コミット可否
- 事前条件:
- 事後条件:
- 手順:

** 7 & 31. CIで設定のビルドの確認をする
- エージェント: GitHub Actions
- インターフェース: cachix、Actionsログ
- 入力: プッシュイベント、ビルド設定
- 出力: ビルド結果、テスト結果、成功/失敗ステータス
- 事前条件:
- 事後条件:
- 手順:

** 8. Garbage Collectionを自動化する
- エージェント: Nixシステム
- インターフェース: /nix/store/、ログ
- 入力: 定期実行スケジュール、削除対象の判定条件
- 出力: 削除されたファイル一覧、解放された容量
- 事前条件:
- 事後条件:
- 手順:

** 9 & 30. flakeのインプットの更新を自動化する
- エージェント: Renovate
- インターフェース: flake.lock、GitHub Pull Request、CI/CD
- 入力: flake.nixの依存関係定義、アップストリームリリース情報
- 出力: 更新されたflake.lock、プルリクエスト、CIテスト結果
- 事前条件: dotfilesの管理者が'nix flake update'を手動で実行し、依存関係を更新する必要がある状態。
- 事後条件: flakeの依存関係の更新が自動でプルリクエストとして提案され、CIテスト成功後に自動で統合される状態。
- 手順:
  1. スケジュールされた時刻に、flake.nix内の依存関係を基に、アップストリームの新しいリリースを確認する。
  2. 更新が検出されると、flake.lockを更新してプルリクエストを作成する。
  3. GitHub ActionsでCIによる自動テストが実行される。
  4. 全てのテストに成功した場合、プルリクエストを自動的にマージする。

** 10. 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
- エージェント: nh
- インターフェース: nixpkgs、出力結果
- 入力: 検索キーワード、パッケージ名
- 出力: 検索結果、パッケージ情報、インストール方法
- 事前条件:
- 事後条件:
- 手順:

** 11 & 19 & 35. 自身のパッケージリポジトリを持ち、不足パッケージを追加できる
- エージェント: nur-packages
- インターフェース: packages、GitHub Actions
- 入力: パッケージ定義、ビルド設定
- 出力: パッケージ化されたバイナリ、パッケージリポジトリ
- 事前条件:
- 事後条件:
- 手順:

** 12 & 19 & 35. モジュールを追加し、不足設定を補完できる
- エージェント: ディレクトリ構造
- インターフェース: home-manager、NixOS、nix-darwin
- 入力: モジュール定義、設定要求
- 出力: モジュール化された設定、システム統合
- 事前条件:
- 事後条件:
- 手順:

** 13 & 24. Nixでシステムを管理する
- エージェント: Nixシステム
- インターフェース: nix、NixOS、nix-darwin、home-manager
- 入力: システム設定、宣言的設定ファイル
- 出力: 構築されたシステム、ロールバック可能なシステム状態
- 事前条件:
- 事後条件:
- 手順:

** 14 & 18. クラウドの構成を宣言的に管理し、情報をできるだけパブリックに配置する
- エージェント: terraform
- インターフェース: GitHub、Cloudflare、terraform applyの結果
- 入力: インフラ構成定義、クラウドプロバイダー設定
- 出力: デプロイされたインフラストラクチャ、パブリック情報
- 事前条件:
- 事後条件:
- 手順:

** 15. 宣言的なディスク構成を行う
- エージェント: disko
- インターフェース:ssh、ディスクを確認するコマンドの結果
- 入力: ディスク構成定義、パーティション設定
- 出力: 構成されたディスク、ファイルシステム
- 事前条件:
- 事後条件:
- 手順:

** 17. 鍵を共有する
- エージェント: kaki
- インターフェース:GPG、ssh、各ホスト(watari、lawliet、ryuk、rem)
- 入力: 鍵ペア生成要求、共有対象ホスト
- 出力: 共有された鍵、認証設定
- 事前条件:
- 事後条件:
- 手順:

** 18. クロスOS/Archへの対応
- エージェント: Nixシステム
- インターフェース: NixOS、nix-darwin
- 入力: 対象OS/Arch指定、クロスコンパイル設定
- 出力: 各プラットフォーム対応バイナリ、統一設定
- 事前条件:
- 事後条件:
- 手順:

** 20. キーボードの差を吸収できるようにする
- エージェント: xremap & karabiner & qmk
- インターフェース: xremap、karabiner-elements、goku、qmk
- 入力: キーボードレイアウト、キーマップ設定
- 出力: 統一されたキーマップ、デバイス固有の差分吸収
- 事前条件:
- 事後条件:
- 手順:

** 22. 異なる環境で設定したものをmergeできるようにする
- エージェント: git
- インターフェース: git、magit
- 入力: ブランチ情報、変更差分、マージ要求
- 出力: マージされた設定、統合された環境
- 事前条件:
- 事後条件:
- 手順:

** 23. Gitでcheckout出来るようにする
- エージェント: git
- インターフェース git、magit
- 入力: チェックアウト対象コミット、ブランチ情報
- 出力: ロールバックされたシステム状態、バージョン切り替え結果
- 事前条件:
- 事後条件:
- 手順:

** 25. LSPやLinterを導入しておく
- エージェント: emacs
- インターフェース: LSP、flyckeck
- 入力: コードファイル、コード変更イベント
- 出力: コード解析結果、エラー・警告情報、補完候補
- 事前条件:
- 事後条件:
- 手順:

** 26. パスを補完時に存在するかどうかを確認出来るようにする
- エージェント: emacs
- インターフェース: corfu、cape
- 入力: パスの部分入力、ファイルシステム状態
- 出力: パス存在確認結果、補完候補一覧
- 事前条件:
- 事後条件:
- 手順:

** 27. /varや/tmpをクリーンに保つ
- エージェント: impermanence
- インターフェース: NixOS、ssh
- 入力: 永続化するファイルリスト、システム起動イベント
- 出力: クリーンな一時ディレクトリ、永続化されたデータ
- 事前条件:
- 事後条件:
- 手順:

** 28. 不必要なdotfilesが無いか確認をする
- エージェント: xdg-ninja
- インターフェース: home directory
- 入力: ホームディレクトリのスキャン要求、XDG規約情報
- 出力: 不必要なdotfiles一覧、改善推奨事項
- 事前条件:
- 事後条件:
- 手順:

** 29. リポジトリを管理する
- エージェント: ghq
- インターフェース: GitHubリポジトリ
- 入力: リポジトリURL、clone要求、管理コマンド
- 出力: クローンされたリポジトリ、統一されたディレクトリ構造
- 事前条件:
- 事後条件:
- 手順:

** 33. commitメッセージの規則を決める
- エージェント: kaki
- インターフェース: git、magit、Cload Code
- 入力: コミット内容、変更範囲、標準フォーマット
- 出力: 統一されたコミットメッセージ、履歴の統一性
- 事前条件:
- 事後条件:
- 手順:

** 34. ディレクトリを読ませる
- エージェント: Claude Code
- インターフェース: Cloaud.md、jsonの設定ファイル
- 入力: ディレクトリパス、コードベース情報、プロジェクト情報
- 出力: コード解析結果、コード生成、コード改善提案
- 事前条件:
- 事後条件:
- 手順:

** 36. 使用アプリの更新などを通知する
- エージェント: Github
- インターフェース: メール、Github Issue、star
- 入力: リポジトリwatch設定、release情報、starイベント
- 出力: 更新通知、メール、Issue作成
- 事前条件:
- 事後条件:
- 手順:

** 37. 問題点、改善案、タスク、アイディアを管理する
- エージェント: Github Issue
- インターフェース：org-capture、GitHub
- 入力: 問題報告、改善アイデア、タスク要求、プロジェクト情報
- 出力: 管理されたIssue、タスクリスト、進捗状況
- 事前条件:
- 事後条件:
- 手順:

** 38. 要求を文書化する
- エージェント: kaki
- インターフェース: 要求仕様書
- 入力: ビジネス要求、ユーザーストーリー、機能要求
- 出力: 仕様書、要求定義書、ゴールモデル
- 事前条件:
- 事後条件:
- 手順:

** 39. 設計を文書化する
- エージェント: kaki
- インターフェース: 設計仕様書
- 入力: アーキテクチャ設計、システム設計、技術仕様
- 出力: 設計書、アーキテクチャドキュメント、実装ガイド
- 事前条件:
- 事後条件:
- 手順:

** 40. 決定の背景を整理し、立ち戻って更新できるようにする
- エージェント: kaki
- インターフェース: 議事録
- 入力: 決定プロセス、検討内容、決定背景、代替案
- 出力: 決定録、ナレッジドキュメント、将来の参照資料
- 事前条件:
- 事後条件:
- 手順:
