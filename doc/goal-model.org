* nix-shell
#+name: tmp-shell
#+BEGIN_SRC nix :noweb yes
  { pkgs ? import <nixpkgs> {} }:
  pkgs.mkShell { buildInputs = with pkgs; [ plantuml jdk]; }
  #+END_SRC
#+begin_src elisp :nix-shell tmp-shell :results output
  (setq org-plantuml-jar-path "/nix/store/03nh9m73gwwj477yralnsw70igwswfi5-plantuml-1.2025.3/lib/plantuml.jar")
#+end_src
* ゴールモデル

** 色付けの意味
ゴールモデルの各ノードは、その実現形態や責任主体に応じて色分けされています：

- **Yellow（黄色）**: システムによって実現することが期待されるゴール
  - 主にソフトウェアやツールによって自動化・効率化される項目
  - 例: 分散ビルド、キャッシュ利用、CI/CD、pre-commit等

- **Gainsboro（灰色）**: システム以外で実現することが期待されるゴール
  - 主に人間の判断や物理的な作業が必要な項目
  - 例: SSDの増設、適切なcommit粒度の判断、Issue作成等

- **無色**: 複合的な性質を持つゴールまたは分類が明確でないゴール
  - システムと人間の協調が必要な項目や、より抽象的な概念

この色分けにより、自動化の対象となるゴールと人間の判断・作業が必要なゴールを明確に区別し、効率的な開発環境の構築を支援します。

#+begin_src plantuml :nix-shell tmp-shell  :file ゴールモデル.png
  @startmindmap
  !theme materia

  ,* 継続的に進化する、再現可能な開発環境の実現

  ,**[#lightblue] 変更の容易性と拡張性を確保する

  ,*** 開発サイクルを高速化する
  ,**** 素早いビルドが行なえる
  ,*****[#Yellow] 分散ビルドをする
  ,*****[#Yellow] キャッシュを利用する
  ,*****[#Gainsboro] 自宅のデスクトップにSSDを増設する
  ,**** 反復作業を効率化する
  ,*****[#Yellow] 設定変更の影響範囲を意図した範囲に限定できる
  ,*****[#Yellow] 機密情報も一括で管理を可能にする
  ,*****[#Yellow] タスクランナーで普段行うタスクを素早く実行出来るようにする
  ,*****[#Yellow] pre-commitでcommit前にlinterやformatterを適用する
  ,*****[#Yellow] CIでビルドの確認をする
  ,*****[#Yellow] Garbage Collectionを自動化する
  ,*****[#Yellow] flakeのインプットの更新を自動化する
  ,*****[#Yellow] 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化

  ,*** 変更の枠組みを広げる
  ,**** パッケージリポジトリにないパッケージを使用出来るようにする
  ,*****[#Yellow] 自身のパッケージリポジトリを持つ
  ,****** パッケージングのための自動化をする
  ,****[#Yellow] モジュールを追加できる


  ,**[#lightsalmon] 再現性とポータビリティを実現する

  ,*** 再現性の確保
  
  ,**** 宣言的な管理 
  ,*****[#Yellow] 設定のコード化
  ,*****[#Yellow] 宣言的なインフラ管理 
  ,*****[#Yellow] 宣言的なディスク構成

  ,**** 安全な情報管理 
  ,*****[#Yellow] SOPSによる機密情報の暗号化と自動復号
  ,*****[#Yellow] 鍵の安全かつ迅速な共有

  ,*** ポータビリティの実現

  ,**** 環境差の吸収

  ,*****[#Yellow] クロスOS/Arch対応
  ,*****[#Yellow] 不足している機能の追加システム
  ,*****[#Yellow] キーボード等のデバイス差の吸収

  ,**** 柔軟な設定構造 
  ,*****[#Yellow] 設定の共通化と分割
  ,*****[#Yellow] 異なる環境からの設定のマージ

  ,**[#lightgreen] 信頼性の確保

  ,*** 問題が起った時にロールバック出来るようにする
  ,****[#Yellow] Gitでcheckout出来るようにする
  ,****[#Yellow] Nixでシステムを管理する

  ,*** 不具合が起こらないようにする 
  ,****[#Yellow] LSPやLinterを導入しておく
  ,****[#Yellow] パスを補完時に存在するかどうかを確認出来るようにする
  ,**** 副作用を排除する
  ,*****[#Yellow] /varや/tmpをクリーンに保つ
  ,***** ホームディレクトリをクリーンに保つ
  ,****** XDG base directoryに出来るだけ従う
  ,*******[#Yellow] 不必要なdotfilesが無いか確認をする
  ,******[#Yellow] リポジトリを管理する
  ,**** パッケージのversionの更新で環境が壊れないようにする
  ,***** 小まめに更新する
  ,******[#Yellow] 自動で更新するようにする 
  ,******* 更新時にCIをする

  ,*** 不具合の発見をする
  ,****[#Yellow] CI/CDによる事前ビルド
  ,****[#Yellow] commit前にcheckを行なう
  ,*** 不具合の原因を特定する
  ,**** Gitで差分を管理する
  ,*****[#Gainsboro] 適切な粒度でcommitを行なう
  ,*****[#Yellow] commitメッセージの規則を決める
  ,**** AIに確認をしてもらう
  ,*****[#Yellow] ディレクトリを読ませる

  ,*** 不具合の原因を解決する
  ,**** パッケージリポジトリで壊れた場合も自分で修正できるようにする
  ,*****[#Gainsboro] Issueを立てれるようにする
  ,*****[#Yellow] 自分のパッケージリポジトリを使用する
  ,****** CIでビルドとテストを行なう


  ,**[#plum] 進化と知識の管理

  ,***[#Gainsboro] 情報収集をする

  ,*** 次のアクションを決定し、相談できる状態にする
  ,****[#Yellow] 使用アプリの更新を通知する
  ,****[#Yellow] 問題点、改善案、タスク、アイディアを管理する

  ,*** 設計と知見を記録し、道筋を見失わないようにする
  ,****[#Yellow] 要求を文書化する
  ,****[#Yellow] 設計を文書化する
  ,****[#Yellow] 決定の背景を整理し、立ち戻って更新できるようにする

  @endmindmap
#+end_src

#+RESULTS:
[[file:ゴールモデル.png]]

* ゴールの説明

** 継続的に進化する、再現可能な開発環境の実現
- 目的、意図:
   このリポジトリが目指す究極の目的は、ツールや環境の制約から開発者を開放し、本来の創造的な作業に完全集中できる状態を実現することです。環境構築の煩わしさ、OS間の差異、設定変更に伴うリスクといった「摩擦」を極限までゼロに近づけます。このリポジトリは、単なる設定のバックアップではなく、所有者と共に成長し、常に最適な状況へと適応し続ける*「生きた作業基盤」*として設計されています。
- 達成基準:
  1. 迅速な再現性:
    新規ホストのセットアップが、リポジトリのcloneから30分以内に完了する。
  2. 完全な可搬性:
     LinuxとMacOSの間で、作業感に差異が感じられない。
  3. 容易な継続サイクル:
     - 速度
        キーマップ変更のような軽微な設定変更から、task switch 等によるシステムへの適用完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - モジュール性:
        新しいアプリケーションの追加や設定変更が、他の部分に影響を与えることなく、モジュールとして自己完結した形で追加、修正をできる。
  4. 進化と知識の管理:
     主要な設計思想や各ゴールの達成基準がドキュメントとして明記されており、未来の自分が参照した際に、なぜその設計になっているのか迅速に理解できる。
- 現在の状況:
  - 再現性
     MacOSではある程度の速さはでセットアップを出来る気もするが、GUIでの操作などのドキュメント化が不足している。Linuxではしばらくの間OSの再インストールを行っていないためどの程度の再現性があるか不明。
  - 可搬性
     幾つかの設定では共通化できているが、出来ていないものもある。
  - 継続サイクル
     モジュール化はファイル分けなどはうまくできていそうだが、内容の重複などはありそう。
  - ドキュメンテーション
     現状の把握はAIに吐かせたものをそのまま使用しているし、ゴールモデルについても文書化はこれから。org-roamとの連携も課題。

*** 変更の容易性と拡張性を確保する
- 目的、意図:
   日々の情報収集や作業の中で発生する無数の「こうしたい」という思いつきを、集中力を途絶えさせることなく、迅速かつ柔軟にシステムに反映できるようにする。変更のコストを下げることで、アグレッシブな改善とシステムの進化を促進する。
- 達成基準:
  1. 効率性:
     - 速度:
        キーマップ変更のような軽微な設定変更から、適応完了までが1分以内に完了し、設定変更前の作業の集中力が途切れることがない。
     - 自動化
        繰り返し行なうビルドやテストなどのタスクは自動化しておく。
  2. 拡張性:
     - モジュール性:
        新規アプリケーションの追加はapplications/ディレクトリ以下に自己完結したモジュールとして追加をすることができ、コアのロジックの追加を必要としない。
     - 依存関係:
        nixpkgsにないパッケージも、自前のパッケージリポジトリを通じて、容易に追加、利用が出来る。
- 現状と課題
  - 現状
     軽微な変更は素早く行なうことができる。
  - 課題
     Emacsのような大規模なパッケージのビルドがボトルネックとなり、軽微な変更であっても達成基準を(1分以内)を阻害するケースがある。ビルドプロセスの更なる最適化が必要。
  - 課題
    パッケージの追加方法が場当たり的になっており不十分なところも多い。ドキュメント化する必要がある。


**** 開発サイクルを高速化する
- 目的、意図:
   設定変更の度に生じる「待ち時間」と「煩雑な手作業」を徹底的に排除し、開発者の集中力を持続させることを目的とする。
    
- 達成基準:
  1. 高速化:
     - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。

     - emacsのビルドを5分以内に完了する。
        
  2. 自動化:
     設定変更は、関連するファイルの編集するだけでよく、フォーマット、チェック、適用といった一連の作業は、自動化されたツールによって実行される。
- 現状と課題:
  - 現状
     タスクランナーを使用して短かいコマンドで日々の作業を行うことができる
  - 課題
     CIは動作している。
     
  - 課題
     自宅のデスクトップはマシンパワーが弱く、ビルドするのに時間が掛かる。

  - 課題
     pre-commitがどの程度の範囲の活動をしているか把握していない。


***** 素早いビルドが行なえる
- 目的、意図:
   設定変更の際に必ず生じるビルドの時間を短かくすることで、「待ち時間」の削減をし、思考のフローを維持する。
- 達成基準:
  - 時間的目標
    - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - 効率的目標
    - 一度ビルドしたderivationはどのホストであっても再ビルドされることはない。
- 現状と課題:
  - 達成状況: 達成
  - 現状
    - 分散ビルド
       適切に動作している。
    - キャッシュ
       適切に動作している。
****** 分散ビルドが行なえる
- 目的、意図:
   研究室の高性能なPCをビルドに用いることで、ビルドの時間を短縮し思考のフローを維持する。
- agent
   分散ビルドシステム
- 達成基準:
  - 時間目標
    - キーマップ変更のような軽微な設定変更から、task switchによる適用完了までが1分以内に完了する。
    - emacsのビルドを5分以内に完了する。
  - リソース活用目標
    - 自宅のPCとラップトップでは自身を含めて3台のマシンでビルドを行なう。
    - 研究室のマシンでは自身を含めて2台のマシンでビルドを行なう。
- 現況と課題:
  - 達成状況: 達成
  - 現状
    - 全ての分散ビルドを利用できるマシンから全ての接続できるサーバーを利用して分散ビルドを行なうことができる。
    - 全ての分散ビルドを利用できるマシンで分散ビルドに使用するサーバーに接続をすることができる。


****** キャッシュを利用する
- 目的、意図:
   Cachixのバイナリキャッシュを利用することで、ビルド済みのパッケージを再利用し、ビルド時間を短縮する。特に、分散ビルドが利用できない環境(MacBook)での開発サイクルの高速化を目指す。
- agent
   cachix
- 達成基準：
  1. キャッシュヒット率:
     ローカルマシンでのビルド時、変更されたderivation以外の全てのderivationがキャッシュから取得（pull）される。
  2. ビルド時間短縮:
     キャッシュが有効な状態でのビルド時間は、キャッシュがない場合と比較して、体感で半分以下になる（目標: 5分以内）。
- 現状と課題
  - ステータス
     達成済み
  - 現状
    - pullはnix.confにsubstitutersとtrusted-public-keysを設定してあるのでできていそう。
    - pushはGitHub Actionsを経由して行なえている。
****** 自宅のデスクトップにSSDを増設する
***** 反復作業を効率化する
- 目的、意図:
   設定変更の際に付随して発生する、フォーマットやテスト、適用といった反復的な作業を自動化することで、開発者が本来の目的である「本質的な設定内容の検討」のみに集中できる状況を作り出す。
- 達成基準:
   以下の作業が、手動でのコマンドを必要とせずに、適切なタイミングで自動的に実行される。
  1. コード品質の維持:
     ファイル保存時やcommit時に、フォーマットと静的解析が自動で実行される。
  2. テストの実行:
     push時に、システムのビルドテストが自動で実行される。
  3. システムの適用:
     Taskからの単一コマンドでホストを左右されず、ビルドから適用まで一気通貫で実行される。
  4. 定期メンテナンス:
     Nixストアのガベージコレクションやパッケージの更新などの保守作業がスケジュールに基づいて自動で実行される。
- 現状と課題:
  1. コード品質の維持について:
     - 達成状況: 部分的に達成
     - 課題
        pre-commitの設定を把握していない。
  2. テストの実行について:
     - 達成状況: 部分的に達成
     - 現状
        CIでビルドの確認ができる。
     - 課題
        nur-packagesのCIは動作していない。
  3. システムの適用について:
     - 達成状況: 基本達成
     - 現状
        適切なモジュール化ができているため反映させたいホストにまとめて反映ができる。
     - 現状
        機密情報を別途で手作業で管理する必要がない。
     - 現状
        タスクランナーで普段行うタスクを素早く実行できる。
     - 課題
        nhだとnomを使って情報を多く得れるが、いまのところ分散ビルドを使用できない。
  4. 定期メンテナンスについて:
     - 達成状況: 部分的に達成
     - 現状
        Garbage Collectを自動で行っている。
     - 課題
        nix flake updateを手作業で行っている。

****** 設定変更の影響範囲を意図した範囲に限定できる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 機密情報も一括で管理を可能にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** タスクランナーで普段行うタスクを素早く実行出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** pre-commitでcommit前にlinterやformatterを適用する
****** CIでビルドの確認をする
****** Garbage Collectionを自動化する
- 目的、意図
   Nixは大量に容量を必要とし、すぐに容量(特に/boot)を埋め尽してしまう。この問題が発生する度に自身でGarbage Collectをするのは作業効率を低下させるので、自動でGarbage Collectを実行するようにする。
- 達成条件
  - 実行条件:
     どのホストでも週に一度GCを行う。
  - 環境条件:
     容量の問題によって設定変更の失敗が起きない。
- 現状と課題
  - 達成状況 達成
****** flakeのインプットの更新を自動化する
****** 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
**** 変更の枠組みを広げる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージリポジトリにないパッケージを使用出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自身のパッケージリポジトリを持つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* パッケージングのための自動化をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** モジュールを追加できる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 再現性とポータビリティを実現する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 設定をパブリックリポジトリにアップロードする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 機密情報も暗号化をしアップロードする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自動で複合する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 異なるOS、アーキテクチャでも動作するようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 宣言的なディスク構成を行う
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設定を共通化できるものとそうで無いもので分割しておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 共通化のために一部で不足している設定を追加で行なえるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 鍵を共有する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 素早く共有できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 安全に保管出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 情報をクラウドにアップロードしておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** クラウドの構成を宣言的に記述出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** キーボードの差を吸収できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 異なる環境で設定したものをmergeできるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 個々のアプリの要求を明確にしておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 信頼性の確保
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 問題が起った時にロールバック出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Gitでcheckout出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Nixでシステムを管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合が起こらないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** LSPやLinterを導入しておく
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パスを補完時に存在するかどうかを確認出来るようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 副作用を排除する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** /varや/tmpをクリーンに保つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** ホームディレクトリをクリーンに保つ
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* XDG base directoryに出来るだけ従う
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******** 不必要なdotfilesが無いか確認をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* リポジトリを管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージのversionの更新で環境が壊れないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 小まめに更新をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* 自動で更新するようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******** 更新時にCIをする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の発見をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** CI/CDによる事前ビルド
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** commit前にcheckを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の原因を特定する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** Gitで差分を管理する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 適切な粒度でcommitを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** commitメッセージの規則を決める
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** AIに確認をしてもらう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** ディレクトリを読ませる
- 目的、意図: 
- 達成基準: 
- 現在の状況:

**** 不具合の原因を解決する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** パッケージリポジトリで壊れた場合も自分で修正できるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** Issueを立てれるようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 自分のパッケージリポジトリを使用する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

******* CIでビルドとテストを行なう
- 目的、意図: 
- 達成基準: 
- 現在の状況:

*** 進化と知識の管理
- 目的、意図:
   システムの継続的な改善と最適化のためのナレッジマネジメント基盤を構築することを目的とする。技術の進歩、新しいツールの登場、作業フローの変化に対応し、常に最新で最適な開発環境を維持する。また、過去の設計判断、課題解決のプロセス、学習した知見を体系的に記録・管理し、未来の自分や他の開発者が効率的に理解・活用できるようにする。
- 達成基準:
  1. 継続的な情報収集と評価:
     - 新しいベストプラクティスやツールの情報を定期的に収集・評価する仕組みがある
     - 実装したい新機能やツールの利用可能性を迅速に調査できる
  2. 次のアクションを決定し、相談できる状態:
     - 使用しているツールやパッケージの更新情報が自動的に通知される
     - 問題点、改善案、アイディアが適切に記録・管理されている
     - 具体的なアクションプランを策定し、必要に応じて相談できる状態にある
  3. 効果的なタスクと計画管理:
     - 各アプリケーションの要求定義が明確に文書化されている
     - 設計思想とゴールモデルが常に最新の状態で文書化されている
  4. 知識の体系化と継承:
     - 設計判断の根拠と経緯が記録されている
     - 蓄積された知見が検索・参照可能な形で文書化されている
     - 管理方法とワークフローが明確に定義されている
- 現在の状況:
  - 情報収集: 手動で行っており、自動化されていない
  - アクション決定: 更新通知システムが未整備、問題点の管理が体系化されていない
  - 課題管理: GitHub Issuesは設定されているが、体系的な運用はされていない
  - 文書化: ゴールモデルは作成されているが、詳細な設計思想や知見の記録が不足している
  - 管理方法: 明確なワークフローが確立されていない状態

**** 情報収集をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 使用アプリの更新などを通知する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** ベストプラクティスを調査する
- 目的、意図: 
- 達成基準: 
- 現在の状況:


**** 計画を改善し、タスクを管理をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 各アプリで実現したいことの要求定義をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 改善案やアイデアの課題管理をする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設計と知見を記録し、道筋を見失わないようにする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

****** 蓄積された知見をドキュメント化する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 管理方法を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 設計思想を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** ゴールモデルを文書化する
- 目的、意図: 
- 達成基準: 
- 現在の状況:

***** 要求を明確にする
- 目的、意図: 
- 達成基準: 
- 現在の状況:

* エージェント分析
** エージェント分類

*** 分散ビルドシステム
- 担当ゴール: 1. 分散ビルドをする

*** Nixシステム
- 担当ゴール: 8. Garbage Collectionを自動化する, 22. Nixでシステムを管理する

*** Cachix
- 担当ゴール: 2. キャッシュを利用する

*** SOPS
- 担当ゴール: 4. 機密情報も一括で管理を可能にする

*** Task
- 担当ゴール: 5. タスクランナーで普段行うタスクを素早く実行出来るようにする

*** pre-commit
- 担当ゴール: 6. pre-commitでcommit前にlinterやformatterを適用する, 30. commit前にcheckを行なう

*** GitHub Actions
- 担当ゴール: 7. CIでビルドの確認をする, 29. CI/CDによる事前ビルド

*** renovate bot
- 担当ゴール: 9. flakeのインプットの更新を自動化する, 28. 自動で更新するようにする

*** git
- 担当ゴール: 20. 異なる環境で設定したものをmergeできるようにする, 21. Gitでcheckout出来るようにする

*** terraform
- 担当ゴール: 13. 設定をパブリックリポジトリにアップロードする, 18. クラウドの構成を宣言的に記述出来るようにする

*** disko
- 担当ゴール: 14. 宣言的なディスク構成を行う

*** nur-packages
- 担当ゴール: 11. 自身のパッケージリポジトリを持つ, 16. 共通化のために一部で不足している設定を追加で行なえるようにする

*** ghq
- 担当ゴール: 27. リポジトリを管理する

*** xremap & karabiner
- 担当ゴール: 19. キーボードの差を吸収できるようにする

*** emacs
- 担当ゴール: 23. LSPやLinterを導入しておく, 24. パスを補完時に存在するかどうかを確認出来るようにする

*** impermanence
- 担当ゴール: 25. /varや/tmpをクリーンに保つ

*** xdg-ninja
- 担当ゴール: 26. 不必要なdotfilesが無いか確認をする

*** kaki (リポジトリオーナー)
- 担当ゴール: 17. 鍵を共有する, 31. commitメッセージの規則を決める, 36. 要求を文書化する, 37. 設計を文書化する, 38. 決定の背景を整理し、立ち戻って更新できるようにする

*** Claude Code
- 担当ゴール: 32. ディレクトリを読ませる

*** Github Issue
- 担当ゴール: 35. 問題点、改善案、タスク、アイディアを管理する


** Yellowゴールのエージェント割り当て

以下はゴールモデルでYellowに色付けされたゴールに対するエージェント割り当てです。

*** 1. 分散ビルドをする
- エージェント: 分散ビルドシステム
- インターフェース: リモートサーバー、ビルドログ
- 入力: ビルド対象のderivation、リモートサーバー情報
- 出力: ビルド済みの成果物、ビルドログ

*** 2. キャッシュを利用する
- エージェント: cachix
- インターフェース: GitHub Actions、ビルドログ
- 入力: ビルド済みderivation、キャッシュ要求
- 出力: キャッシュされたバイナリ、キャッシュヒット/ミス情報

*** 3 & 21. 設定の適用範囲を適切に制御できる
- エージェント: Nixモジュールシステム
- インターフェース: ディレクトリ構造
- 入力: 設定変更要求、適用対象の指定
- 出力: 指定された範囲への設定適用結果

*** 4 & 16. 機密情報も一括で管理を可能にする
- エージェント: Sops
- インターフェース: 鍵、ビルドログ
- 入力: 機密情報、暗号化キー
- 出力: 暗号化された機密情報、復号化された設定値

*** 5. タスクランナーで普段行うタスクを素早く実行出来るようにする
- エージェント: Task
- インターフェース: switchコマンド、出力結果
- 入力: タスク名、実行パラメータ
- 出力: タスク実行結果、実行時間

*** 6 & 32. commit前にlinterとformatterを適用する
- エージェント: pre-commit
- インターフェース: formatter、linter、commitログ
- 入力: 変更されたファイル、コミット要求
- 出力: フォーマット済みファイル、リンター結果、コミット可否

*** 7 & 31. CIで設定のビルドの確認をする
- エージェント: GitHub Actions
- インターフェース: cachix、Actionsログ
- 入力: プッシュイベント、ビルド設定
- 出力: ビルド結果、テスト結果、成功/失敗ステータス

*** 8. Garbage Collectionを自動化する
- エージェント: Nixシステム
- インターフェース: /nix/store/、ログ
- 入力: 定期実行スケジュール、削除対象の判定条件
- 出力: 削除されたファイル一覧、解放された容量

*** 9 & 30. flakeのインプットの更新を自動化する
- エージェント: renovate bot
- インターフェース: flake.lock、pull request
- 入力: 更新チェック要求、依存関係情報
- 出力: 更新されたflake.lock、プルリクエスト

*** 10. 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
- エージェント: nh
- インターフェース: nixpkgs、出力結果
- 入力: 検索キーワード、パッケージ名
- 出力: 検索結果、パッケージ情報、インストール方法

*** 11 & 19 & 35. 自身のパッケージリポジトリを持ち、不足パッケージを追加できる
- エージェント: nur-packages
- インターフェース: packages、GitHub Actions
- 入力: パッケージ定義、ビルド設定
- 出力: パッケージ化されたバイナリ、パッケージリポジトリ

*** 12 & 19 & 35. モジュールを追加し、不足設定を補完できる
- エージェント: ディレクトリ構造
- インターフェース: home-manager、NixOS、nix-darwin
- 入力: モジュール定義、設定要求
- 出力: モジュール化された設定、システム統合
   
*** 13 & 24. Nixでシステムを管理する
- エージェント: Nixシステム
- インターフェース: nix、NixOS、nix-darwin、home-manager
- 入力: システム設定、宣言的設定ファイル
- 出力: 構築されたシステム、ロールバック可能なシステム状態
   
*** 14 & 18. クラウドの構成を宣言的に管理し、情報をできるだけパブリックに配置する
- エージェント: terraform
- インターフェース: GitHub、Cloudflare、terraform applyの結果
- 入力: インフラ構成定義、クラウドプロバイダー設定
- 出力: デプロイされたインフラストラクチャ、パブリック情報

*** 15. 宣言的なディスク構成を行う
- エージェント: disko
- インターフェース:ssh、ディスクを確認するコマンドの結果
- 入力: ディスク構成定義、パーティション設定
- 出力: 構成されたディスク、ファイルシステム

*** 17. 鍵を共有する
- エージェント: kaki
- インターフェース:GPG、ssh、各ホスト(watari、lawliet、ryuk、rem)
- 入力: 鍵ペア生成要求、共有対象ホスト
- 出力: 共有された鍵、認証設定

*** 18. クロスOS/Archへの対応
- エージェント: Nixシステム
- インターフェース: NixOS、nix-darwin
- 入力: 対象OS/Arch指定、クロスコンパイル設定
- 出力: 各プラットフォーム対応バイナリ、統一設定

*** 20. キーボードの差を吸収できるようにする
- エージェント: xremap & karabiner & qmk
- インターフェース: xremap、karabiner-elements、goku、qmk
- 入力: キーボードレイアウト、キーマップ設定
- 出力: 統一されたキーマップ、デバイス固有の差分吸収

*** 22. 異なる環境で設定したものをmergeできるようにする
- エージェント: git
- インターフェース: git、magit
- 入力: ブランチ情報、変更差分、マージ要求
- 出力: マージされた設定、統合された環境

*** 23. Gitでcheckout出来るようにする
- エージェント: git
- インターフェース git、magit
- 入力: チェックアウト対象コミット、ブランチ情報
- 出力: ロールバックされたシステム状態、バージョン切り替え結果

*** 25. LSPやLinterを導入しておく
- エージェント: emacs
- インターフェース: LSP、flyckeck
- 入力: コードファイル、コード変更イベント
- 出力: コード解析結果、エラー・警告情報、補完候補

*** 26. パスを補完時に存在するかどうかを確認出来るようにする
- エージェント: emacs
- インターフェース: corfu、cape
- 入力: パスの部分入力、ファイルシステム状態
- 出力: パス存在確認結果、補完候補一覧

*** 27. /varや/tmpをクリーンに保つ
- エージェント: impermanence
- インターフェース: NixOS、ssh
- 入力: 永続化するファイルリスト、システム起動イベント
- 出力: クリーンな一時ディレクトリ、永続化されたデータ

*** 28. 不必要なdotfilesが無いか確認をする
- エージェント: xdg-ninja
- インターフェース: home directory
- 入力: ホームディレクトリのスキャン要求、XDG規約情報
- 出力: 不必要なdotfiles一覧、改善推奨事項

*** 29. リポジトリを管理する
- エージェント: ghq
- インターフェース: GitHubリポジトリ
- 入力: リポジトリURL、clone要求、管理コマンド
- 出力: クローンされたリポジトリ、統一されたディレクトリ構造

*** 33. commitメッセージの規則を決める
- エージェント: kaki
- インターフェース: git、magit、Cload Code
- 入力: コミット内容、変更範囲、標準フォーマット
- 出力: 統一されたコミットメッセージ、履歴の統一性

*** 34. ディレクトリを読ませる
- エージェント: Cloude Code
- インターフェース: Cloaud.md、jsonの設定ファイル
- 入力: ディレクトリパス、コードベース情報、プロジェクト情報
- 出力: コード解析結果、コード生成、コード改善提案

*** 36. 使用アプリの更新などを通知する
- エージェント: Github
- インターフェース: メール、Github Issue、star
- 入力: リポジトリwatch設定、release情報、starイベント
- 出力: 更新通知、メール、Issue作成

*** 37. 問題点、改善案、タスク、アイディアを管理する
- エージェント: Github Issue
- インターフェース：org-caputure、GitHub
- 入力: 問題報告、改善アイデア、タスク要求、プロジェクト情報
- 出力: 管理されたIssue、タスクリスト、進捗状況

*** 38. 要求を文書化する
- エージェント: kaki
- インターフェース: 要求仕様書
- 入力: ビジネス要求、ユーザーストーリー、機能要求
- 出力: 仕様書、要求定義書、ゴールモデル

*** 39. 設計を文書化する
- エージェント: kaki
- インターフェース: 設計仕様書
- 入力: アーキテクチャ設計、システム設計、技術仕様
- 出力: 設計書、アーキテクチャドキュメント、実装ガイド
   
*** 40. 決定の背景を整理し、立ち戻って更新できるようにする
- エージェント: kaki
- インターフェース: 議事録
- 入力: 決定プロセス、検討内容、決定背景、代替案
- 出力: 決定録、ナレッジドキュメント、将来の参照資料
 
   
* 操作の導出

** 1. 分散ビルドの設定をする
- エージェント: 分散ビルドシステム
- インターフェース: リモートサーバー、ビルドログ
- 入力: ビルド対象のderivation、リモートサーバー情報
- 出力: ビルド済みの成果物、ビルドログ
- 事前条件: ビルドサーバーに接続できない。
- 事後条件: ビルドサーバーに接続ができる。
- 手順:
  1. localでパスフレーズのないssh keyを作成する
  2. /root/.ssh/configに設定を作成する
  3. buildMachineの設定をNixに書く
  4. ホスト側に公開鍵を送る

** 2. キャッシュを利用する
- エージェント: cachix
- インターフェース: GitHub Actions、ビルドログ
- 入力: ビルド済みderivation、キャッシュ要求
- 出力: キャッシュされたバイナリ、キャッシュヒット/ミス情報
- 事前条件: 
- 事後条件: 
- 手順: 

** 3 & 21. 設定の適用範囲を適切に制御できる
- エージェント: Nixモジュールシステム
- インターフェース: ディレクトリ構造
- 入力: 設定変更要求、適用対象の指定
- 出力: 指定された範囲への設定適用結果
- 事前条件: 
- 事後条件: 
- 手順: 

** 4 & 16. 機密情報も一括で管理を可能にする
- エージェント: Sops
- インターフェース: 鍵、ビルドログ
- 入力: 機密情報、暗号化キー
- 出力: 暗号化された機密情報、復号化された設定値
- 事前条件: 
- 事後条件: 
- 手順: 

** 5. タスクランナーで普段行うタスクを素早く実行出来るようにする
- エージェント: Task
- インターフェース: switchコマンド、出力結果
- 入力: タスク名、実行パラメータ
- 出力: タスク実行結果、実行時間
- 事前条件: 
- 事後条件: 
- 手順: 

** 6 & 32. commit前にlinterとformatterを適用する
- エージェント: pre-commit
- インターフェース: formatter、linter、commitログ
- 入力: 変更されたファイル、コミット要求
- 出力: フォーマット済みファイル、リンター結果、コミット可否
- 事前条件: 
- 事後条件: 
- 手順: 

** 7 & 31. CIで設定のビルドの確認をする
- エージェント: GitHub Actions
- インターフェース: cachix、Actionsログ
- 入力: プッシュイベント、ビルド設定
- 出力: ビルド結果、テスト結果、成功/失敗ステータス
- 事前条件: 
- 事後条件: 
- 手順: 

** 8. Garbage Collectionを自動化する
- エージェント: Nixシステム
- インターフェース: /nix/store/、ログ
- 入力: 定期実行スケジュール、削除対象の判定条件
- 出力: 削除されたファイル一覧、解放された容量
- 事前条件: 
- 事後条件: 
- 手順: 

** 9 & 30. flakeのインプットの更新を自動化する
- エージェント: Renovate
- インターフェース: flake.lock、GitHub Pull Request、CI/CD
- 入力: flake.nixの依存関係定義、アップストリームリリース情報
- 出力: 更新されたflake.lock、プルリクエスト、CIテスト結果
- 事前条件: dotfilesの管理者が'nix flake update'を手動で実行し、依存関係を更新する必要がある状態。
- 事後条件: flakeの依存関係の更新が自動でプルリクエストとして提案され、CIテスト成功後に自動で統合される状態。
- 手順:
  1. スケジュールされた時刻に、flake.nix内の依存関係を基に、アップストリームの新しいリリースを確認する。
  2. 更新が検出されると、flake.lockを更新してプルリクエストを作成する。
  3. GitHub ActionsでCIによる自動テストが実行される。
  4. 全てのテストに成功した場合、プルリクエストを自動的にマージする。

** 10. 使用したい新規ツールがnixpkgsに含まれるかの検索の高速化
- エージェント: nh
- インターフェース: nixpkgs、出力結果
- 入力: 検索キーワード、パッケージ名
- 出力: 検索結果、パッケージ情報、インストール方法
- 事前条件: 
- 事後条件: 
- 手順: 

** 11 & 19 & 35. 自身のパッケージリポジトリを持ち、不足パッケージを追加できる
- エージェント: nur-packages
- インターフェース: packages、GitHub Actions
- 入力: パッケージ定義、ビルド設定
- 出力: パッケージ化されたバイナリ、パッケージリポジトリ
- 事前条件: 
- 事後条件: 
- 手順: 

** 12 & 19 & 35. モジュールを追加し、不足設定を補完できる
- エージェント: ディレクトリ構造
- インターフェース: home-manager、NixOS、nix-darwin
- 入力: モジュール定義、設定要求
- 出力: モジュール化された設定、システム統合
- 事前条件: 
- 事後条件: 
- 手順: 
  
** 13 & 24. Nixでシステムを管理する
- エージェント: Nixシステム
- インターフェース: nix、NixOS、nix-darwin、home-manager
- 入力: システム設定、宣言的設定ファイル
- 出力: 構築されたシステム、ロールバック可能なシステム状態
- 事前条件: 
- 事後条件: 
- 手順: 
  
** 14 & 18. クラウドの構成を宣言的に管理し、情報をできるだけパブリックに配置する
- エージェント: terraform
- インターフェース: GitHub、Cloudflare、terraform applyの結果
- 入力: インフラ構成定義、クラウドプロバイダー設定
- 出力: デプロイされたインフラストラクチャ、パブリック情報
- 事前条件: 
- 事後条件: 
- 手順: 

** 15. 宣言的なディスク構成を行う
- エージェント: disko
- インターフェース:ssh、ディスクを確認するコマンドの結果
- 入力: ディスク構成定義、パーティション設定
- 出力: 構成されたディスク、ファイルシステム
- 事前条件: 
- 事後条件: 
- 手順: 

** 17. 鍵を共有する
- エージェント: kaki
- インターフェース:GPG、ssh、各ホスト(watari、lawliet、ryuk、rem)
- 入力: 鍵ペア生成要求、共有対象ホスト
- 出力: 共有された鍵、認証設定
- 事前条件: 
- 事後条件: 
- 手順: 

** 18. クロスOS/Archへの対応
- エージェント: Nixシステム
- インターフェース: NixOS、nix-darwin
- 入力: 対象OS/Arch指定、クロスコンパイル設定
- 出力: 各プラットフォーム対応バイナリ、統一設定
- 事前条件: 
- 事後条件: 
- 手順: 

** 20. キーボードの差を吸収できるようにする
- エージェント: xremap & karabiner & qmk
- インターフェース: xremap、karabiner-elements、goku、qmk
- 入力: キーボードレイアウト、キーマップ設定
- 出力: 統一されたキーマップ、デバイス固有の差分吸収
- 事前条件: 
- 事後条件: 
- 手順: 

** 22. 異なる環境で設定したものをmergeできるようにする
- エージェント: git
- インターフェース: git、magit
- 入力: ブランチ情報、変更差分、マージ要求
- 出力: マージされた設定、統合された環境
- 事前条件: 
- 事後条件: 
- 手順: 

** 23. Gitでcheckout出来るようにする
- エージェント: git
- インターフェース git、magit
- 入力: チェックアウト対象コミット、ブランチ情報
- 出力: ロールバックされたシステム状態、バージョン切り替え結果
- 事前条件: 
- 事後条件: 
- 手順: 

** 25. LSPやLinterを導入しておく
- エージェント: emacs
- インターフェース: LSP、flyckeck
- 入力: コードファイル、コード変更イベント
- 出力: コード解析結果、エラー・警告情報、補完候補
- 事前条件: 
- 事後条件: 
- 手順: 

** 26. パスを補完時に存在するかどうかを確認出来るようにする
- エージェント: emacs
- インターフェース: corfu、cape
- 入力: パスの部分入力、ファイルシステム状態
- 出力: パス存在確認結果、補完候補一覧
- 事前条件: 
- 事後条件: 
- 手順: 

** 27. /varや/tmpをクリーンに保つ
- エージェント: impermanence
- インターフェース: NixOS、ssh
- 入力: 永続化するファイルリスト、システム起動イベント
- 出力: クリーンな一時ディレクトリ、永続化されたデータ
- 事前条件: 
- 事後条件: 
- 手順: 

** 28. 不必要なdotfilesが無いか確認をする
- エージェント: xdg-ninja
- インターフェース: home directory
- 入力: ホームディレクトリのスキャン要求、XDG規約情報
- 出力: 不必要なdotfiles一覧、改善推奨事項
- 事前条件: 
- 事後条件: 
- 手順: 

** 29. リポジトリを管理する
- エージェント: ghq
- インターフェース: GitHubリポジトリ
- 入力: リポジトリURL、clone要求、管理コマンド
- 出力: クローンされたリポジトリ、統一されたディレクトリ構造
- 事前条件: 
- 事後条件: 
- 手順: 

** 33. commitメッセージの規則を決める
- エージェント: kaki
- インターフェース: git、magit、Cload Code
- 入力: コミット内容、変更範囲、標準フォーマット
- 出力: 統一されたコミットメッセージ、履歴の統一性
- 事前条件: 
- 事後条件: 
- 手順: 

** 34. ディレクトリを読ませる
- エージェント: Cloude Code
- インターフェース: Cloaud.md、jsonの設定ファイル
- 入力: ディレクトリパス、コードベース情報、プロジェクト情報
- 出力: コード解析結果、コード生成、コード改善提案
- 事前条件: 
- 事後条件: 
- 手順: 

** 36. 使用アプリの更新などを通知する
- エージェント: Github
- インターフェース: メール、Github Issue、star
- 入力: リポジトリwatch設定、release情報、starイベント
- 出力: 更新通知、メール、Issue作成
- 事前条件: 
- 事後条件: 
- 手順: 

** 37. 問題点、改善案、タスク、アイディアを管理する
- エージェント: Github Issue
- インターフェース：org-caputure、GitHub
- 入力: 問題報告、改善アイデア、タスク要求、プロジェクト情報
- 出力: 管理されたIssue、タスクリスト、進捗状況
- 事前条件: 
- 事後条件: 
- 手順: 

** 38. 要求を文書化する
- エージェント: kaki
- インターフェース: 要求仕様書
- 入力: ビジネス要求、ユーザーストーリー、機能要求
- 出力: 仕様書、要求定義書、ゴールモデル
- 事前条件: 
- 事後条件: 
- 手順: 

** 39. 設計を文書化する
- エージェント: kaki
- インターフェース: 設計仕様書
- 入力: アーキテクチャ設計、システム設計、技術仕様
- 出力: 設計書、アーキテクチャドキュメント、実装ガイド
- 事前条件: 
- 事後条件: 
- 手順: 
  
** 40. 決定の背景を整理し、立ち戻って更新できるようにする
- エージェント: kaki
- インターフェース: 議事録
- 入力: 決定プロセス、検討内容、決定背景、代替案
- 出力: 決定録、ナレッジドキュメント、将来の参照資料
- 事前条件: 
- 事後条件: 
- 手順: 
