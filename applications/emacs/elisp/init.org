#+TITLE: Configurations for GNU Emacs
#+AUTHOR: minera
* Header
#+begin_src emacs-lisp :tangle yes
  ;; init.el --- My init.el -*- lexical-binding: t -*-
  ;; Configurations for Emacs
#+end_src
* autoload-if-found
#+begin_src emacs-lisp :tangle yes
  (defun autoload-if-found (functions file &optional docstring interactive type)
    "Set autoload iff FILE has found."
    (when (locate-library file)
      (dolist (f functions)
        (autoload f file docstring interactive type))))
#+end_src
* exec-path-from-shell[macOS]
#+begin_src emacs-lisp :tangle yes
    (when (memq window-system '(mac ns x))
      (require 'exec-path-from-shell)
      (dolist (var '("GNUPGHOME" "NIX_PATH"))
      (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize))
#+end_src
* パッケージを読み込まないようにする
#+begin_src emacs-lisp :tangle yes
 ; (require 'profiler) ;; Profiler start removed
 ; (profiler-start 'cpu) ;; Profiler start removed
  (setq debug-on-error t)
  (defconst my-saved-file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+end_src
* じかん計測
#+begin_src emacs-lisp :tangle yes
    ;(require 'esup)
  ;;;;;;;;;;;;;;;;;;(setq esup-depth 0)
#+end_src
* builtin properties
#+begin_src emacs-lisp :tangle yes
  (setq user-full-name "Yusuke Kakinuma")
  (setq default-directory "~/")
#+end_src
#+begin_src emacs-lisp :tangle yes
  (setq custom-file (locate-user-emacs-file "custom.el"))
#+end_src
* GPG
** epa-file
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(epa-file-enable) "epa-file" nil t)

(add-hook 'emacs-startup-hook #'epa-file-enable)

(fset 'epg-wait-for-status 'ignore)

(with-eval-after-load 'epa-hook
  (setopt epa-file-encrypt-to '("49B685E0425E0EA4BADADA84AAEBE97A7B2544C0")))

(with-eval-after-load 'epa-file
  ;; config
  (setopt epa-file-select-keys 'silent)
  (setopt epa-file-cache-passphrase-for-symmetric-encryption t))

(with-eval-after-load 'epg-config
  ;; config
  (setopt epg-pinentry-mode 'loopback))
#+end_src
* 一般設定
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'smooth-scroll-mode)
  (autoload 'smooth-scroll-mode "smooth-scroll" nil t)

  (setq scroll-conservatively 35)
  (setq scroll-step 1)
  (setq scroll-margin 5)
  (setq scroll-preserve-screen-position t)

  (setq blink-cursor-idle-time 1)  ;; 入力停止から点滅開始までの秒数
  (setq blink-cursor-interval 0.3)  ;; 点滅の間隔（秒）
  (setq blink-cursor-blinks 0)      ;; 0は無限に点滅を続けることを意味する
  (blink-cursor-mode -1)             ;; カーソル点滅モードを有効化
#+end_src
** Clip board
Waylandでペーストできるようにする設定
#+begin_src emacs-lisp :tangle yes
  (when (equal system-type 'gnu/linux)
  (setq wl-copy-process nil)
    (defun wl-copy (text)
      (setq wl-copy-process (make-process :name "wl-copy"
                                          :buffer nil
                                          :command '("wl-copy" "-f" "-n")
                                          :connection-type 'pipe
                                          :noquery t))
      (process-send-string wl-copy-process text)
      (process-send-eof wl-copy-process))
  (defun wl-paste ()
    (if (and wl-copy-process (process-live-p wl-copy-process))
        nil
      (shell-command-to-string "wl-paste -n")))
  (setq interprogram-cut-function 'wl-copy)
  (setq interprogram-paste-function 'wl-paste)
  )
#+end_src
** 起動時間測定
#+begin_src emacs-lisp :tangle yes
  (defconst my/before-load-init-time (current-time))

  ;;;###autoload
  (defun my/load-init-time ()
    "Loading time of user init files including time for `after-init-hook'."
    (let ((time1 (float-time
                  (time-subtract after-init-time my/before-load-init-time)))
          (time2 (float-time
                  (time-subtract (current-time) my/before-load-init-time))))
      (message (concat "Loading init files: %.0f [msec], "
                       "of which %.f [msec] for `after-init-hook'.")
               (* 1000 time1) (* 1000 (- time2 time1)))))
  (add-hook 'after-init-hook #'my/load-init-time t)

  (defvar my/tick-previous-time my/before-load-init-time)

  ;;;###autoload
  (defun my/tick-init-time (msg)
    "Tick boot sequence at loading MSG."
    (when my/loading-profile-p
      (let ((ctime (current-time)))
        (message "---- %5.2f[ms] %s"
                 (* 1000 (float-time
                          (time-subtract ctime my/tick-previous-time)))
                 msg)
        (setq my/tick-previous-time ctime))))

  (defun my/emacs-init-time ()
    "Emacs booting time in msec."
    (interactive)
    (message "Emacs booting time: %.0f [msec] = `emacs-init-time'."
             (* 1000
                (float-time (time-subtract
                             after-init-time
                             before-init-time)))))

  (add-hook 'after-init-hook #'my/emacs-init-time)
#+end_src
* UI
** theme
*** Modus Theme
  #+begin_src emacs-lisp :tangle yes
    (add-hook 'emacs-startup-hook
    	  #'(lambda ()
    	      (when (require 'modus-themes)
    		(load-theme 'modus-operandi))))

    (with-eval-after-load 'modus-themes
      (setq modus-themes-italic-constructs  t)
      (setq modus-themes-bold-constructs  t)
      (setq modus-themes-mode-line  '(moody borderless))
      (setq modus-themes-prompts  '(italic bold))
      (setq custom-safe-themes  t)
      )
#+end_src
** tree-sitter
#+begin_src emacs-lisp :tangle yes
  (setq treesit-font-lock-level  4)
  (setq major-mode-remap-alist
        '(
  	(nix-mode  nix-ts-mode)
  					;  (emacs-lisp-mode . emacs-lisp-ts-mode)
  	(yaml-mode  yaml-ts-mode)
  	;(python-mode  python-ts-mode)
  	)
        )
#+end_src
** perfect-margin
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'perfect-margin-mode)
  (autoload 'perfect-margin-mode "perfect-margin" nil t)
  (with-eval-after-load 'perfect-margin
    (setq perfect-margin-ignore-filters  nil)
    (setq perfect-margin-ignore-regexps  nil)
    (setq perfect-margin-visible-width  108)
    (setq split-width-threshold  107)
    (add-to-list 'perfect-margin-ignore-regexps "*which-key")
    )
#+end_src
** icon
*** nerd-icons
#+begin_src emacs-lisp :tangle yes
  (use-package nerd-icons
     )
  ;(add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)
   (use-package nerd-icons-corfu
     :after nerd-icons
     )
#+end_src
** winnum
#+begin_src emacs-lisp :tangle yes
 ; (use-package winum
 ;   )
#+end_src
** tab bar
バッファをウインドウの管理をうまくできていないので、あまりつかいこなせていない。
 #+begin_src emacs-lisp :tangle yes
  ; (centaur-tabs-mode  t)
  ; (autoload-if-found 'centaur-tabs-mode "centaur-tabs")
  ; (setq centaur-tabs-style  "alternate")
  ; (setq centaur-tabs-set-icons  t)
  ; (setq centaur-tabs-icon-type  'nerd-icons)
  ; (setq centaur-tabs-set-bar  'under)
  ; (setq x-underline-at-descent-line  t)
  ; (centaur-tabs-headline-match)
  ; (setq centaur-tabs-set-bar 'under)
  ; (setq x-underline-at-descent-line t)
 #+end_src
** minus
#+begin_src emacs-lisp :tangle yes
  (autoload 'minions-mode "minions" nil t)
  (add-hook 'emacs-startup-hook #'minions-mode)
#+end_src
** Moody
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'moody-replace-mode-line-buffer-identification)
  (add-hook 'emacs-startup-hook #'moody-replace-vc-mode)
  (autoload 'moody-replace-mode-line-buffer-identification "moody" nil t)
  (autoload 'moody-replace-vc-mode "moody" nil t)
  (with-eval-after-load 'moody
  (setq moody-mode-line-height 26)
  )
#+end_src
** spacious-padding
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'spacious-padding-mode)
  (autoload 'spacious-padding-mode "spacious-padding" nil t)
  (with-eval-after-load 'spacious-padding
    (setq spacious-padding-widths
  	'(
  	  :internal-border-width 5
  	  :right-divider-width 0
  	  :mode-line-width 0
  	  :left-fringe-width 5
  	  ))
    )
 #+end_src
* 入力支援
** ryo-modal-mode
#+begin_src emacs-lisp :tangle yes
 ; (leaf ryo-modal
  ;  :ensure t
  ;    )
#+end_src
** evil-mode
#+begin_src emacs-lisp :tangle yes
 ; (leaf evil
 ;   :ensure t
 ;   )

#+end_src
** kakoune
#+begin_src emacs-lisp :tangle yes
 ; (leaf kakoune
 ;   :ensure t
 ;   :after ryo-modal multiple-cursors expand-region
 ;   :bind ("C-z" . ryo-modal-mode)
 ;   )
#+end_src
** mewo
#+begin_src emacs-lisp :tangle yes
  (use-package meow
    ;:require meow
   :custom
   (meow-use-clipboard  t)
    (meow-expand-hint-counts  nil)
    :config
    (defun meow-setup ()
      (setq meow-cheatsheet-layout meow-cheatsheet-layout-dvp)
     (meow-leader-define-key
      '("?" . meow-cheatsheet))
      (meow-motion-overwrite-define-key
       ;; custom keybinding for motion state
       '("<escape>" . ignore))
      (meow-normal-define-key
       '("?" . meow-cheatsheet)
       ;; Ctrl key;;;;;;;


                                          ;'("*" . meow-expand-0)
       ;; puni
       '(", a (" . puni-wrap-round)
       '(", a [" . puni-wrap-square)
       '(", a {" . puni-wrap-curly)
       '(", a <" . puni-wrap-angle)
       '(", a d" . puni-splice)
       '(", s l" . puni-slurp-forward)
       '(", b a" . puni-barf-forward)

       '("%" . mark-whole-buffer)

       '("=" . meow-expand-9)
       '("!" . meow-expand-8)
       '("[" . meow-expand-7)
       '("]" . meow-expand-6)
       '("{" . meow-expand-5)
       '("+" . meow-expand-4)
       '("}" . meow-expand-3)
       '(")" . meow-expand-2)
       '("(" . meow-expand-1)
       '("1" . digit-argument)
       '("2" . digit-argument)
       '("3" . digit-argument)
       '("4" . digit-argument)
       '("5" . digit-argument)
       '("6" . digit-argument)
       '("7" . digit-argument)
       '("8" . digit-argument)
       '("9" . digit-argument)
       '("0" . digit-argument)
       '("-" . negativargument)
       '(";" . meow-reverse)
       '("*" . meow-inner-of-thing)
       '("." . meow-bounds-of-thing)
       '("<" . meow-beginning-of-thing)
       '(">" . meow-end-of-thing)
       '("a" . meow-append)
       '("A" . meow-forward-bracket)
       '("b" . meow-back-word) ;元はmeow-back-word
       '("B" . meow-back-symbol)
       '("c" . meow-swap-grab)
       '("C" . mc/mark-next-like-this)
       '("p" . projectile-command-map)
       '("P" . meow-backward-delete)
       '("e" . meow-line)
       '("E" . meow-goto-line)
      '("f" . meow-find)
      '("<escape>" . meow-cancel-selection)
       '("G" . meow-grab)
       '("d" . meow-left)
       '("D" . meow-left-expand)
       '("i" . meow-insert)
       '("I" . meow-mark-symbol)
       '("j" . meow-join)
       '("k" . meow-kill)
       '("l" . meow-till)
       '("m" . meow-block)
     '("M" . meow-to-block)
       '("s" . meow-next)
       '("S" . meow-next-expand)
       '("o" . meow-open-below)
       '("O" . meow-open-above)
       '("t" . meow-prev)
       '("T" . meow-prev-expand)
       '("q" . meow-quit)
       '("Q" . kmacro-start-macro)
       '("r" . meow-change)
       '("R" . meow-replace)
       '("h" . meow-search)
       '("n" . meow-right)
       '("N" . meow-right-expand)
       '("u" . vundo)
       '("U" . meow-undo-in-selection)
                                         ;'("v" . meow-visit)
       '("v i" . meow-inner-of-thing) ;; Inner
     '("v a" . meow-bounds-of-thing) ;; Around
      '("v b" . meow-block) ;; Block
      '("v c" . puni-mark-list-around-point) ;; Contents
       '("v x" . puni-mark-sexp-around-point) ;; eXpression
      '("v l" . meow-line) ;; Line
       '("v s" . meow-mark-symbol) ;; Symbol
       '("v w" . meow-mark-word) ;; Word
       '("v v" . puni-expand-region) ;; Expand
       '("v r" . rectangle-mark-mode) ;; Rectangle
       '("w" . meow-next-word)
       '("W" . meow-next-symbol)
       '("x" . meow-save)
       '("X" . meow-sync-grab)
       '("y" . meow-yank)
       '("z" . meow-pop-selection)
       '("'" . repeat)
     ;'("g" . avy-goto-char-timer)
       )
      )
    (meow-setup)
    (meow-global-mode)
    )
  ;(add-hook 'emacs-startup-hook #'meow-global-mode)
  ;
  ;(autoload 'meow-global-mode "meow" nil t)
  ;(with-eval-after-load 'meow
  ;   (meow-normal-define-key
  ;       '("?" . meow-cheatsheet)
         ;; Ctrl key;;;;;;;


                                            ;'("*" . meow-expand-0)
         ;; puni
  ;       '(", a (" . puni-wrap-round)
  ;       '(", a [" . puni-wrap-square)
  ;       '(", a {" . puni-wrap-curly)
  ;       '(", a <" . puni-wrap-angle)
  ;       '(", a d" . puni-splice)
  ;       '(", s l" . puni-slurp-forward)
  ;       '(", b a" . puni-barf-forward)

  ;       '("%" . mark-whole-buffer)

  ;       '("=" . meow-expand-9)
  ;       '("!" . meow-expand-8)
  ;       '("[" . meow-expand-7)
  ;       '("]" . meow-expand-6)
  ;       '("{" . meow-expand-5)
  ;       '("+" . meow-expand-4)
  ;       '("}" . meow-expand-3)
  ;       '(")" . meow-expand-2)
  ;       '("(" . meow-expand-1)
  ;       '("1" . digit-argument)
  ;       '("2" . digit-argument)
  ;       '("3" . digit-argument)
  ;       '("4" . digit-argument)
  ;       '("5" . digit-argument)
  ;       '("6" . digit-argument)
  ;       '("7" . digit-argument)
  ;       '("8" . digit-argument)
  ;       '("9" . digit-argument)
  ;       '("0" . digit-argument)
  ;       '("-" . negativargument)
  ;       '(";" . meow-reverse)
  ;       '("*" . meow-inner-of-thing)
  ;       '("." . meow-bounds-of-thing)
  ;       '("<" . meow-beginning-of-thing)
  ;      '(">" . meow-end-of-thing)
  ;       '("a" . meow-append)
  ;       '("A" . meow-forward-bracket)
  ;       '("b" . meow-back-word) ;元はmeow-back-word
  ;       '("B" . meow-back-symbol)
  ;       '("c" . meow-swap-grab)
  ;       '("C" . mc/mark-next-like-this)
  ;       '("p" . meow-delete)
  ;       '("P" . meow-backward-delete)
  ;       '("e" . meow-line)
  ;       '("E" . meow-goto-line)
  ;      '("f" . meow-find)
  ;      '("<escape>" . meow-cancel-selection)
  ;       '("G" . meow-grab)
  ;       '("d" . meow-left)
  ;       '("D" . meow-left-expand)
  ;       '("i" . meow-insert)
  ;       '("I" . meow-mark-symbol)
  ;       '("j" . meow-join)
  ;       '("k" . meow-kill)
  ;       '("l" . meow-till)
  ;       '("m" . meow-block)
  ;     '("M" . meow-to-block)
  ;       '("s" . meow-next)
  ;       '("S" . meow-next-expand)
  ;       '("o" . meow-open-below)
  ;       '("O" . meow-open-above)
  ;       '("t" . meow-prev)
  ;       '("T" . meow-prev-expand)
  ;       '("q" . meow-quit)
  ;       '("Q" . kmacro-start-macro)
  ;       '("r" . meow-change)
  ;       '("R" . meow-replace)
  ;       '("h" . meow-search)
  ;       '("n" . meow-right)
  ;       '("N" . meow-right-expand)
  ;       '("u" . vundo)
  ;       '("U" . meow-undo-in-selection)
                                           ;'("v" . meow-visit)
  ;       '("v i" . meow-inner-of-thing) ;; Inner
  ;     '("v a" . meow-bounds-of-thing) ;; Around
  ;      '("v b" . meow-block) ;; Block
  ;      '("v c" . puni-mark-list-around-point) ;; Contents
  ;       '("v x" . puni-mark-sexp-around-point) ;; eXpression
  ;      '("v l" . meow-line) ;; Line
  ;       '("v s" . meow-mark-symbol) ;; Symbol
  ;       '("v w" . meow-mark-word) ;; Word
  ;       '("v v" . puni-expand-region) ;; Expand
  ;       '("v r" . rectangle-mark-mode) ;; Rectangle
  ;       '("w" . meow-next-word)
  ;       '("W" . meow-next-symbol)
  ;       '("x" . meow-save)
  ;       '("X" . meow-sync-grab)
  ;       '("y" . meow-yank)
  ;       '("z" . meow-pop-selection)
  ;       '("'" . repeat)
        ;'("g" . avy-goto-char-timer)
  ;       )
  ;  )
#+end_src
** puni
 #+begin_src emacs-lisp :tangle yes
   ;(with-eval-after-load 'puni
   ;(keymap-global-unset "C-j")
   ;(use-package puni
   ;    :bind
   ;    ("C-j i" . puni-mark-list-around-point)
   ;    ("C-j a" . puni-mark-sexp-around-point)
   ;    ("C-j e" . puni-expand-region)
   ;    )
   ;)
   (require 'puni)
 #+end_src

** which key
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook #'which-key-mode)
  (autoload 'which-key-mode "which-key" nil t)
#+end_src
** vundo
#+begin_src emacs-lisp :tangle yes
  (autoload 'vundo "vundo" nil t)
  (with-eval-after-load 'vundo
    (keymap-set vundo-mode-map "d" 'vundo-backward)
    (keymap-set vundo-mode-map "n" 'vundo-forward)
    (keymap-set vundo-mode-map "s" 'vundo-next)
    (keymap-set vundo-mode-map "t" 'vundo-previous)
    (keymap-set vundo-mode-map "b" 'vundo-diff)
    )

#+end_src
** dmacro
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'dmacro
    (use-package dmacro
      )
  					;:custom `((dmacro-key . ,(kbd "C-b")))  ;; C-b を dmacro のキーにする
  					;:global-minor-mode global-dmacro-mode
    (defun my-indent-rigidly-right-to-tab-stop (beg end)
      "Indent all lines between BEG and END rightward to a tab stop and keep the region active."
      (interactive "r")
      (let ((deactivate-mark nil))  ; 選択範囲を解除しない
        (indent-rigidly-right-to-tab-stop beg end)))

    (global-set-key (kbd "C->") 'my-indent-rigidly-right-to-tab-stop)
    (defun select-to-end-of-buffer ()
      "Select from the current point to the end of the buffer."
      (interactive)
      (set-mark (point)) ;; 現在のポイントをマークに設定
     (use-package multiple-cursors
      )
     (goto-char (point-max))) ;; バッファ末尾に移動
      (use-package multiple-cursors
      )
  (global-set-key (kbd "M->") 'select-to-end-of-buffer)
      (use-package multiple-cursors
      )
  )
#+end_src
** multiple-cursors
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(mc/mark-next-like-this) "multiple-cursors" nil t)
  (
with-eval-after-load 'multiple-cursors
    )
#+end_src
* ミニバッファ補完
** vercico
#+begin_src emacs-lisp :tangle yes
  (autoload 'vertico-mode "vertico-autoloads" nil t)

  (add-hook 'emacs-startup-hook #'vertico-mode)

  (with-eval-after-load 'vertico
  (setopt vertico-count 8)
  (setopt vertico-cycle t)
  (keymap-set vertico-map "DEL" 'vertico-directory-delete-char))
#+end_src
** marginalia
#+begin_src emacs-lisp :tangle yes
  (autoload 'marginalia-mode "marginalia" nil t)
  (add-hook 'emacs-startup-hook #'marginalia-mode)
#+end_src
** orderless
#+begin_src emacs-lisp :tangle yes
   (use-package orderless
     :custom
     (orderless-matching-styles
   			     '(orderless-prefixes
   			       ))
     (completion-styles  '(orderless basic))
     (completion-category-overrides  '((file
                                         (styles basic partial-completion))
   				       (command (styles orderless))))
     )
   ;(autoload 'orderless-all-completions "orderless" nil t)
   ;(autoload 'orderless-try-completion "orderless" nil t)

   ;(with-eval-after-load 'minibuffer
   ;  (setq orderless-matching-styles
  ; 	'(orderless-prefixes
   ;	  ))
   ;  (setq completion-styles  '(orderless basic))
   ;  (setq completion-category-overrides  '((file
   ;					  (styles basic partial-completion))
   ;					 (command (styles orderless))))
    ; )
#+end_src
** consult
#+begin_src emacs-lisp :tangle yes
  (autoload 'consult-buffer "consult")
  (keymap-global-set "C-x b" 'consult-buffer)
  #+end_src
** affe
#+begin_src emacs-lisp :tangle yes
  (autoload 'affe-find "affe" nil t)
  (autoload 'affe-find-home "affe" nil t)
  (autoload 'affe-grep "affe" nil t)

  (with-eval-after-load 'affe
    (defun affe-find-home ()
      "Affeをホームルートから実行する"
      (interactive)
      (affe-find "~")
      )
    (setopt affe-highlight-function  'orderless-highlight-matches)
    (setopt affe-find-command  "fd --color=never --full-path")
    )
  (keymap-global-set "M-g f" 'affe-find)
  (keymap-global-set "M-g h" 'affe-find-home)
  (keymap-global-set "M-g g" 'affe-grep)
#+end_src
* 入力補完
** corfu
#+begin_src emacs-lisp :tangle yes
;  (autoload-if-found '(global-corfu-mode) "corfu" nil t)
;  (autoload-if-found '(corfu-popupinfo-mode) "corfu-popupinfo" nil t)

;  (add-hook 'emacs-startup-hook #'global-corfu-mode)

;  (with-eval-after-load 'corfu
;  (setq corfu-auto  t)
;  (setq corfu-auto-delay  0)
;  (setq corfu-popupinfo-delay  0)
;  (setq corfu-quit-no-match  'separator)
;  (setq corfu-auto-prefix  1)
;  (setq corfu-cycle  t)
;  (setq corfu-quit-at-boundary nil)
;  (setq text-mode-ispell-word-completion  nil)
;  (setq tab-always-indent  'complete)
;  (corfu-popupinfo-mode)
;  (keymap-unset corfu-map "RET")
;  (keymap-unset corfu-map "<up>")
;  (keymap-unset corfu-map "<remap> <next-line>")
;  (keymap-unset corfu-map "<remap> <previous-line>")
;  (keymap-unset corfu-map "<down>")
;  (keymap-set corfu-map "C-n" 'corfu-next)
;  (keymap-set corfu-map "C-p" 'corfu-previous)
;  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)
;  )
#+end_src
** cape
#+begin_src emacs-lisp :tangle yes
;  (autoload-if-found '(cape-file cape-keyword) "cape" nil t)

;  (with-eval-after-load 'minibuffer
;    (add-to-list 'completion-at-point-functions #'cape-file)
    ;(add-to-list 'completion-at-point-functions #'cape-keyword)
;    )
#+end_src
* キーバインディング
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-q"  'scroll-down-command) ;元々M-vだったが、入力しにくいので、そっちをvterm-toggleにした
#+end_src
* ellama
#+begin_src emacs-lisp :tangle yes
  ;(require 'llm-gemini)
  ;(require 'ellama)
  ;(use-package ellama
  ;  :ensure t
  ;  :bind ("C-c e" . ellama-transient-main-menu)
  ;  :init
  ;  (require 'llm-ollama)
  ;  (setq ellama-provider ;; setopt は非推奨なので setq を使用
  ;	  (make-llm-gemini
  ;	   :key (funcall(plist-get (nth 0 (auth-source-search :host "gemini")) :secret))
  ;	   :chat-model "gemini-2.5-pro-preview-03-25"
  ;	   ))
  					;(make-llm-ollama
  					;     		   :scheme "http"
  					;                 :host "ollama.mdip2home.com"
  					;     		   :port 80
  					;                 :chat-model "Qwen2.5:14b"
  					;                 :embedding-model "Qwen2.5:14b"
  					;		   :default-chat-non-standard-params '(("num_ctx" . 32768))))


  ;  :config
  ;  (defcustom ellama-japanese-correction-prompt-template
  ;    "
  ;あなたは論理的な思考を重視する編集者です。
  ; あなたはZettelkastenのエキスパートであり、元のメモの意図と表現を尊重しつつ、改善点を指摘するアドバイザーです。以下のZettelkastenメモを、元の内容を大きく変更せずに、より良くするための添削をお願いします。\n
  ;
  ;重視する点（指摘してほしいこと）:\n
  ;* アトミック（単一のアイデアか？）: 一つのメモに複数のアイデアが混在していないか確認し、もし混在していればどのように分割できるか、元の構成を尊重しつつ指摘してください。\n
  ;* 明確性・簡潔性: メモの内容が不明確、または冗長な箇所があれば、元の表現を活かしたより良い表現の可能性を提案してください。\n
  ;添削してほしいメモ:\n%s\n
  ;出力形式:\n
  ;* 元のメモに対する具体的な改善点の指摘をリスト形式で記述してください。（例：「この部分は複数のアイデアを含んでいる可能性があります。具体的にはAとBのアイデアです。分割するなら〜」「『それ』が指す内容が少し曖昧かもしれません。明確にするなら〜」など）\n
  ;* 修正が必要な場合でも、大幅な書き換えは行わず、修正箇所の指摘と、修正案（複数可）の提示*にとどめてください。\n
  ;* 変更提案の理由を簡潔に説明してください\n
  ;       "
  ;    :group 'ellama
  ;    :type 'string)
  ;  (defun ellama-japanese-correction ()
  ;    "Summarize selected region or current buffer."
  ;    (interactive)
  ;    (let ((text (if (region-active-p)
  ;               	    (buffer-substring-no-properties (region-beginning) (reg;ion-end))
  ;               	  (buffer-substring-no-properties (point-min) (point-max)));))
  ;      (ellama-instant (format ellama-japanese-correction-prompt-template
  ;     			      text))))

  ;  )
    #+end_src
* aidermacs
#+begin_src emacs-lisp :tangle yes
     (with-eval-after-load 'aidermacs
  (use-package aidermacs
    :bind
    ("C-c i" . aidermacs-transient-menu)
    :custom
    (aidermacs-backend  'comint)
    (aidermacs-vterm-multiline-newline-key  "S-<return>")
    (aidermacs-use-architect-mode  nil)
    (aidermacs-default-model   "gemini/gemini-2.5-pro-preview-03-25")
    :config
    ;(setenv "GEMINI_API_KEY" (funcall(plist-get (nth 0 (auth-source-search :host "gemini")) :secret)))
    )
  )
#+end_src
* claude-code-ide
#+begin_src emacs-lisp :tangle yes
   (require 'claude-code-ide)
#+end_src
* emigo
#+begin_src emacs-lisp :tangle yes
#+end_src
* yasnippet
#+begin_src emacs-lisp :tangle yes
  ;(autoload-if-found '(yas-global-mode) "yasnippet" nil t)
  ;(yas-global-mode)
#+end_src
* lsp-bridge
#+begin_src emacs-lisp :tangle yes
   (add-hook 'emacs-startup-hook #'global-lsp-bridge-mode)
   (autoload 'global-lsp-bridge-mode "lsp-bridge")
   (with-eval-after-load 'lsp-bridge
     (yas-global-mode)
     (setq lsp-bridge-nix-lsp-server "nil")
     (setq lsp-bridge-enable-with-tramp t)
     (setq lsp-bridge-remote-start-automatically t)
     (setq lsp-bridge-enable-search-words nil)
     (setq lsp-bridge-auto-format-code t)
     (setq lsp-bridge-auto-format-code-idle 10)
     (setq lsp-bridge-enable-org-babel t)
     (setq lsp-bridge-enable-hover-diagnostic t)
     (setq acm-enable-tabnine nil)
     (setq acm-enable-search-file-words nil)
     (setq acm-enable-ctag nil)
     (setq acm-enable-telega nil)
     ; for rust
     (setq lsp-bridge-enable-inlay-hint t)
  ;   (setq lsp-bridge-log-level "debug")
     )
#+end_src
* lsp-mode
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(lsp lsp-deferred lsp-org lsp-register-client make-lsp-client) "lsp-mode" nil t)
  (autoload-if-found '(lsp-lens-mode lsp-lens-refresh lsp-lens--enable) "lsp-lens" nil t)
  (autoload-if-found '(lsp-modeline-workspace-status-mode lsp-modeline-code-actions-mode) "lsp-modeline" nil t)
  (autoload-if-found '(lsp-headerline-breadcrumb-mode) "lsp-headerline" nil t)
  (autoload-if-found '(lsp-diagnostics-mode) "lsp-diagnostics" nil t)

;   (with-eval-after-load 'lsp-mode
;     (setq lsp-completion-provider :none)
;     (autoload 'lsp-lens-mode "lsp-lens" nil t)
;     (autoload 'lsp-lens--enable "lsp-lens" nil t)
;          (defun my-lsp-mode-setup ()
;         "LSP利用時に追加の補完設定を行う"
;         (add-hook 'completion-at-point-functions #'cape-file nil t))
;  	     (add-hook 'lsp-mode-hook #'my-lsp-mode-setup)
;   )

  ;(use-package lsp-mode
  ;  :custom
  ;  (lsp-keymap-prefix  "M-p")
  ;  (lsp-log-in  nil) ;パフォーマンスに大きく影響するらしい
  ;  :hook
  ;  (lsp-mode-hook . lsp-enable-which-key-integration)
  ;         ( lsp-mode-hook . my-lsp-mode-setup)
  ;  補完をorderlessで絞れるようにする
  ;  ;(lsp-completion-mode-hook . (lambda ()
  ;				(setq-local completion-category-defaults
  ;					    (assoc-delete-all 'lsp-capf completion-category-defaults)));)
  ;  )

;  (defun lsp-booster--advice-json-parse (old-fn &rest args)
  					; "Try to parse bytecode instead of json."
;    (or
;     (when (equal (following-char) ?#)
;       (let ((bytecode (read (current-buffer))))
;         (when (byte-code-function-p bytecode)
;           (funcall bytecode))))
;     (apply old-fn args)))
;  (advice-add (if (progn (require 'json)
;                         (fboundp 'json-parse-buffer))
;                  'json-parse-buffer
;                'json-read)
;              :around
;              #'lsp-booster--advice-json-parse);

;  (defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
;    "Prepend emacs-lsp-booster command to lsp CMD."
;    (let ((orig-result (funcall old-fn cmd test?)))
;      (if (and (not test?)                             ;; for check lsp-server-present?
;               (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
;               lsp-use-plists
;               (not (functionp 'json-rpc-connection))  ;; native json-rpc
;               (executable-find "emacs-lsp-booster"))
;          (progn
;            (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
;              (setcar orig-result command-from-exec-path))
;            (message "Using emacs-lsp-booster for %s!" orig-result)
;            (cons "emacs-lsp-booster" orig-result))
;        orig-result)))
;  (advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src
* lsp-ui
#+begin_src emacs-lisp :tangle yes
;  (autoload 'lsp-ui-mode "lsp-ui" nil t)
;  (with-eval-after-load 'lsp-mode
;    (add-hook 'lsp-mode-hook #'lsp-ui-mode))
#+end_src
* tmampのread-only問題への対処
#+begin_src emacs-lisp :tangle yes
  (add-hook 'find-file-hook
            (lambda ()
              (when (file-remote-p (buffer-file-name))
                (set (make-local-variable 'inhibit-read-only) t)
                (fset (make-local-variable 'file-writable-p) (lambda (filename) t))
                (set (make-local-variable 'buffer-read-only) nil))))
#+end_src
* 言語固有の設定
** nix
#+begin_src emacs-lisp :tangle yes
  ;(use-package nix-ts-mode
  ;  :mode
  ;  (("\\.nix\\'" . nix-ts-mode))
  ;  :hook
  ;  (nix-ts-mode-hook . nixfmt-on-save-mode)
  ;  (nix-ts-mode-hook . lsp)
  ;  )
  (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-ts-mode))
  (autoload 'nix-ts-mode "nix-ts-mode" nil t)
 ; (with-eval-after-load 'nix-ts-mode
 ;   (add-hook 'nix-ts-mode-hook 'lsp)
 ;  )
#+end_src
** yaml
#+begin_src emacs-lisp :tangle yes
  (autoload 'yaml-mode "yaml-mode" nil t)
  ;(use-package yaml-mode
  ;  )
  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
  ;(use-package yaml-ts-mode
  ;  :mode
  ;  ("\\.ya?ml\\'")
  ;  )
  (autoload 'yaml-ts-mode "yaml-ts-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-ts-mode))
  (add-to-list 'major-mode-remap-alist '(yaml-mode . yaml-ts-mode))
#+end_src
** rust
#+begin_src emacs-lisp :tangle yes
       ;(use-package rust-mode
       ;   :custom
       ;   (rust-mode-treesitter-derive  t)
       ;   (rust-format-on-save  t)
          ;:hook
          ;(rust-mode-hook  lsp)
      ;    )
      ; (add-hook 'rust-mode-hook 'eglot-ensure)
  ;     (defun my/find-rust-project-root (dir)
  ;        (when-let ((root (locate-dominating-file dir "Cargo.toml")))
  ;          (list 'vc 'Git root)))

  ;     (defun my/rust-mode-hook ()
  ;       (setq-local project-find-functions (list #'my/find-rust-project-root)))

  ;     (add-hook 'rustic-mode-hook #'my/rust-mode-hook)
      (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
  (autoload 'rust-mode "rust-mode" nil t)

      ;(require 'rust-mode)
      ;(add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
      ;(setq rust-mode-treesitter-derive t)
      (with-eval-after-load 'rust-mode
        (setq rust-mode-treesitter-derive t)
        )
    ;  (require 'rust-mode)
    ;  (require 'inheritenv)
    ;  (setq rust-mode-treesitter-derive t)
    ;  (with-eval-after-load 'inheritenv
    ;   (inheritenv-add-advice #'rustic-compilation)
    ;    (require 'rustic nil t)
    ;    (require 'flycheck)
    ;    (setq rustic-format-on-save t)
    ;    (setq rustic-lsp-client nil)
    ;    ;(add-hook 'rustic-mode-hook 'lsp)
    ;    (push 'rustic-clippy flycheck-checkers)
    ;(add-hook 'rustic-mode-hook 'flycheck-mode)
    ;    )
#+end_src
** Python
#+begin_src emacs-lisp :tangle yes
     ;(add-hook 'python-ts-mode-hook 'ruff-format-on-save-mode)
     ;(leaf ruff-format
     ;  :ensure t
     ;  )
   ;(use-package python-mode
   ;  )
 ;  (autoload 'python-mode "python-mode" nil t)
 ; (autoload 'python-ts-mode "python-mode" nil t)
 ;  (add-to-list 'auto-mode-alist '("\\.py$" . python-ts-mode))
 ; (add-to-list 'major-mode-remap-alist '(python-mode . python-ts-mode))
  ; (add-hook 'python-ts-mode-hook (lambda ()
  ; 				  (require 'lsp-pyright)
  ; 				  (lsp)))
  ; (use-package lsp-pyright
  ;   :custom (lsp-pyright-langserver-command "pyright") ;; or basedpyright
  ;   :hook (python-ts-mode . (lambda ()
  ;                           (require 'lsp-pyright)
  ;                           (lsp))))  ; or lsp-deferred
  ;  (add-hook 'python-ts-mode-hook
 ; 	    (lambda ()
  ;	      (require 'lsp-pyright)
  ;	      (lsp)))
  ;(with-eval-after-load 'lsp-pyright
  ;  (setq lsp-pyright-langserver-command "pyright")
  ;  )
#+end_src
** Lean4
#+begin_src emacs-lisp :tangle yes
   (add-to-list 'auto-mode-alist '("\\.lean\\'" . lean4-mode))
   (autoload 'lean4-mode "lean4-mode" nil t)
  (add-hook 'lean4-mode-hook (lambda ()
  			     (lsp-mode)))
  ;(with-eval-after-load 'lean4-mode
   ; (require 'lsp-mode)
   ; )
#+end_src
** Common Lisp
#+begin_src emacs-lisp :tangle yes
  ;(require 'sly-autoloads)

  ;(with-eval-after-load 'sly
   ; (setopt inferior-lisp-program "sbcl")
   ; (setopt sly-command-switch-to-existing-lisp 'always))
#+end_src
** typst
#+begin_src emacs-lisp :tangle yes
    (add-to-list 'auto-mode-alist '("\\.typ\\'" . typst-ts-mode))
    (autoload 'typst-ts-mode "typst-ts-mode" nil t)
  (setq typst-ts-mode-watch-option "--open")

  ;typst-previewだと保存しなくても同期するようになる
  (setq typst-preview-browser "qutebrowser")
#+end_src
** terraform
#+begin_src emacs-lisp :tangle yes
  (add-to-list 'auto-mode-alist '("\\.tf\\'" . terraform-mode))
  (autoload 'terraform-mode "terraform-mode" nil t)
  (with-eval-after-load 'terraform-mode
  ;  (add-hook 'torraform-mode-hook 'lsp)
   )
#+end_src
** plantuml
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(plantuml-mode) "plantuml-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.pu$" . plantuml-mode))
#+end_src
** Tex
#+begin_src emacs-lisp :tangle yes
  ;; AUCTeXの設定を遅延ロード
  (with-eval-after-load 'latex
    (setq TeX-default-mode 'japanese-latex-mode)
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-master nil)
    (setq TeX-view-program-selection '((output-pdf "PDF Tools")))
    (setq japanese-TeX-engine-default 'platex)
    (setq TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view)))
    (setq TeX-PDF-from-DVI "Dvipdfmx"))

  ;; 保存時に自動コンパイル
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  ;(add-hook 'LaTeX-mode-hook
  ;         (lambda ()
  ;            (add-hook 'after-save-hook ('TeX-command-run-all nil))))
  (setq TeX-PDF-from-DVI  '"Dvipdfmx")
  (with-eval-after-load 'auctex
    (require 'auctex-latexmk)
    (auctex-latexmk-setup))
#+end_src
*** atomic-chrome
chromeの編集をemacsのバッファ内から行なえるようにするもの。
キーバインドや検索など慣れた動作で編集ができるようになる。
同期がほぼ同時にできて快適に操作できる。
課題として、Overleafでカーソルもスクロールできるはずなのだが、できていないことと、補完が効いていないことがある。補完はLeTeXのemacsの設定かもしれない。
#+begin_src emacs-lisp :tangle yes
  (require 'atomic-chrome)
  (atomic-chrome-start-server)
  (setq atomic-chrome-url-major-mode-alist
        '(("overleaf.com" . LaTeX-mode)))
#+end_src
** ledger
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(ledger-mode) "ledger-mode" nil t)
  (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
#+end_src
* org
** org
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (setq org-directory  "~/dropbox")

    (setq org-todo-keywords '((sequence  "TODO(t)" "WAIT(w)" "SOMEDAY(s)" "PROJECT(p)" "|" "DONE(d)" "CANCEL(c)") ))

    (setq org-startup-folded  t)
    (setq org-startup-truncated  nil)
    (setq org-hide-emphasis-markers  t);boldなどの*を隠す
    ;(setq  org-emphasis-regexp-components  '("[:alnum:][:nonascii:][:punct:]" "[:alnum:][:nonascii:][:punct:]" "[:space:]" "." 1));*の前後にspaceが要らないように


    (setq org-todo-keyword-faces
  	'(("TODO" . (:foreground "white" :background "red" :weight bold))
  	  ("WAIT" . org-warning)
  	  ("SOMEDAY" . (:foreground "white" :background "pink" :weight bold))
  	  ("DONE(d)" . "yellow")
  	  ("CANCEL" . org-warning)
  	  ("PROJECT" . (:foreground "white" :background "purple" :weight bold))
  	  ))
    (setq org-tag-alist
  	'(("HOME" . ?h)
  	  ("LAB" . ?l)
  	  ("PC" . ?p)
  	  ("desk" . ?d)
  	  ("smartphone" . ?s)
  	  ("anywhere" . ?a)
  	  ("movie" . ?m)
  	  ("Kana" . ?k)
  	  ))
    (setq org-return-follows-link  t)
    (regexp-opt '("Tasks" "Notes"))


  					;habit周り
    (setq org-habit-show-habits-only-for-today  t)
    (add-to-list 'org-modules 'org-habit t)
    )
#+end_src
** org-clock
#+begin_src emacs-lisp :tangle yes
  (setq org-clock-clocktable-default-properties
        '(:maxlevel 10
                    :lang "ja"
                    :scope agenda-with-archives
                    :block today
                    :level 4))
  (keymap-global-set "C-c C-x C-j" 'org-clock-goto)
  (keymap-global-set "C-c C-x C-o" 'org-clock-out)
#+end_src
** org-agenda
#+begin_src emacs-lisp :tangle yes
  (autoload 'org-agenda "org-agenda" nil t)

  (with-eval-after-load 'org-agenda
    (setq org-agenda-start-on-weekday  nil); agendaの日々の始まりを今日に
    (setq org-agenda-start-day  "today")
    (setq org-agenda-skip-scheduled-if-done  '("DONE" "CANCEL"));スケジュールでDONEとCANCELを無視するようにする

    (defun my/org-archive-to-trash ()
      "Move the current subtree to ~/dropbox/trash.org instead of the default archive location"
      (interactive)
      (let ((org-archive-location "~/dropbox/trash.org::"))
        (org-agenda-archive)))

    (keymap-set org-agenda-mode-map "t" 'org-agenda-previous-item)
    (keymap-set org-agenda-mode-map "s" 'org-agenda-next-item)
    (keymap-set org-agenda-mode-map "e" 'org-agenda-todo)
    (define-key org-agenda-mode-map (kbd "#") 'my/org-archive-to-trash)
    )
  (keymap-global-set "C-c a"  'org-agenda)
#+end_src
** org-super-agenda
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
  (use-package org-super-agenda
    :custom
    (org-agenda-files  '("~/dropbox/inbox/inbox.org" "~/dropbox/habit.org" "~/dropbox/kana.org" "~/dropbox/calendar.org"))
    (org-agenda-todo-ignore-scheduled  t)
    (org-agenda-custom-commands
      '(
         ;; Removed duplicate "w" key, renamed the second one to "w2" for review
         ;; Consider choosing a more meaningful key or merging the logic
         ("w" "review"
          (
           (agenda "週の振り返り"
                   (
                    (org-agenda-span 'week)
                    (org-agenda-overriding-header "来週の予定")
                     )
                   )
           (todo "TODO"
                 ((org-agenda-prefix-format " ")
                  (org-super-agenda-groups
                   '(
                     (:name "やること" :todo "TODO")
                   (:discard (:anything t))
                 ))
           ))
           )
          )
         ("g" "Garbage Tasks List"
         ((alltodo ""
                ((org-super-agenda-groups
                  '((:name "Completed Tasks"
                     :todo ("DONE" "CANCEL")
                     :or (:scheduled t :deadline t))))))))
         (
          "d" "TODO"
          (
           (todo "TODO"
                 ((org-agenda-prefix-format " ")
                  (org-super-agenda-groups
                   '(
                     (:name "やること" :todo "TODO")
                   (:discard (:anything t))
                 ))
           ))
           )
          )
         ("h" "Home"
          (
           (agenda "今日のこと"
                   ((org-agenda-span 'day))
                   )
           (todo "TODO"
                 ((org-agenda-prefix-format " ")
                  (org-super-agenda-groups
                   '(
                     ;; Corrected full-width dot and ensured tags are strings
                     (:name "TODO" :tag ("PC" "smartphone" "desk" "HOME" "home" "anywhere"))
                     (:discard (:anything t))
                     ))
                  ))
           )
          )
         ;; Renamed duplicate key "w" to "w2" - please adjust if needed
         ("w2" "review 2"
          (
           (agenda "週の振り返り (2)" ; Adjusted title
                   ((org-agenda-span 'week)
                    (org-agenda-overriding-header "来週の予定 (2)") ; Adjusted header
                    )
                   )
           (todo "TODO"
                 ((org-agenda-prefix-format " ")
                  (org-super-agenda-groups
                   '(
                     ;; Corrected full-width dot
                     (:name "TODO" :todo "TODO")
                     (:discard (:anything t))
                     ))
                  ))
           )
          )
         ("l" "lab"
          (
           (agenda "今日のこと"
                   ((org-agenda-span 'day))
                   )
           (todo "TODO"
                 ((org-agenda-prefix-format " ")
                  (org-super-agenda-groups
                   '(
                     (:name "TODO" :tag ("PC" "smartphone" "desk" "lab" "LAB" "anywhere"))
                     (:discard (:anything t))
                     ))
                  ))
           )
          )
         )
     )
    :config
    (org-super-agenda-mode)
    )
  )
#+end_src
** khalorg (Google Calendar)
#+begin_src emacs-lisp :tangle yes
  (defun my/calendar-sync ()
    "Synchronize Google Calendar using vdirsyncer and khalorg."
    (interactive)
    (let ((output-buffer (get-buffer-create "*Calendar Sync*")))
      (with-current-buffer output-buffer
        (erase-buffer)
        (insert "Synchronizing calendar...\n"))
      (display-buffer output-buffer)
      (set-process-sentinel
       (start-process "calsync" output-buffer "calsync")
       (lambda (process event)
         (when (string-match-p "finished" event)
           (message "Calendar synchronization completed")
           (when (get-file-buffer "~/dropbox/calendar.org")
             (with-current-buffer (get-file-buffer "~/dropbox/calendar.org")
               (revert-buffer t t t))))))))

  (defun my/calendar-auto-revert ()
    "Auto-revert calendar.org after external changes."
    (when (and buffer-file-name
               (string-match-p "calendar\\.org$" buffer-file-name))
      (auto-revert-mode 1)))

  (add-hook 'org-mode-hook #'my/calendar-auto-revert)

  (defvar my/calendar-name "shizhaoyoujie@gmail.com"
    "Default calendar name for khalorg operations.")

  (defun my/calendar-add-event ()
    "Add a new event to Google Calendar via khalorg.
Prompts for title, date, time, location, and description.
The event is added to khal and can be synced to Google Calendar."
    (interactive)
    (require 'org-id)
    (let* ((title (read-string "Event title: "))
           (date (org-read-date nil nil nil "Event date: "))
           (start-time (read-string "Start time (HH:MM): " "09:00"))
           (end-time (read-string "End time (HH:MM): " "10:00"))
           (location (read-string "Location (optional): "))
           (description (read-string "Description (optional): "))
           (uid (org-id-uuid))
           (timestamp (format "<%s %s-%s>" date start-time end-time))
           (org-content (concat "* " title "\n"
                                timestamp "\n"
                                ":PROPERTIES:\n"
                                ":UID: " uid "\n"
                                (unless (string-empty-p location)
                                  (concat ":LOCATION: " location "\n"))
                                ":END:\n"
                                (unless (string-empty-p description)
                                  (concat description "\n")))))
      (with-temp-buffer
        (insert org-content)
        (let ((exit-code (call-process-region (point-min) (point-max)
                                              "khalorg" nil nil nil
                                              "new" my/calendar-name)))
          (if (zerop exit-code)
              (message "Event '%s' added to calendar. Run M-x my/calendar-sync or C-c c s to sync." title)
            (error "Failed to add event to calendar"))))))

  (defun my/calendar-add-and-sync ()
    "Add a new event and immediately sync with Google Calendar."
    (interactive)
    (my/calendar-add-event)
    (my/calendar-sync))

  ;; Calendar keybindings (using C-c k prefix for khal/khalorg)
  (keymap-global-set "C-c k a" #'my/calendar-add-event)
  (keymap-global-set "C-c k s" #'my/calendar-sync)
  (keymap-global-set "C-c k A" #'my/calendar-add-and-sync)
#+end_src
** org-archive
#+begin_src emacs-lisp :tangle yes
 ; (defun my/org-archive-to-trash ()
 ;   "Move the current subtree to ~/dropbox/trash.org instead of the default archive location"
 ;   (interactive)
 ;   (let ((org-archive-location "~/dropbox/trash.org::"))
 ;     (org-agenda-archive)))
 ; (define-key org-agenda-mode-map (kbd "#") 'my/org-archive-to-trash)
#+end_src
** org-capture
#+begin_src emacs-lisp :tangle yes
(defun my/org-agenda-to-string (agenda-type)
      "Generate agenda string for the current week using a temporary file."
      (let ((temp-agenda-file (make-temp-file "org-agenda-"))
            (org-agenda-buffer nil)) ; 読み取り専用バッファを使わないようにする
        (save-window-excursion
          (org-agenda nil agenda-type) ; Agenda ビューを生成
          (org-agenda-write temp-agenda-file)) ; 一時ファイルに書き出し
        (with-temp-buffer
          (insert-file-contents temp-agenda-file) ; 一時ファイルの内容を読み込む
          (goto-char (point-min))
          ;; 不要な部分を整形 (例: ヘッダー削除)
          (kill-whole-line)
          (buffer-string)))) ; 最終的な文字列として返す

    (keymap-global-set "C-c c" 'org-capture)
    (autoload 'org-capture "org-capture" nil t)
    (with-eval-after-load 'org-capture
      (let* ((current-time (current-time))
             ;; 現在の日付から土曜日までの日数を計算
             (days-to-saturday (mod (- 6 (string-to-number (format-time-string "%w" current-time))) 7))
             ;; 今週の土曜日を計算
             (start-of-week (time-add
                             (time-add current-time (days-to-time days-to-saturday)) (days-to-time -6)))
             ;; 翌週の金曜日を計算
             (end-of-week (time-add start-of-week (days-to-time 6)))
             ;; フォーマットされた日付
             (start-day (format-time-string "%m%d" start-of-week))
             (end-day (format-time-string "%m%d" end-of-week))
             ;; 年を取得
             (year (format-time-string "%Y" start-of-week))
             ;; アーカイブディレクトリとファイル名
             (archive-dir (expand-file-name (format "~/dropbox/archive/%s/" year)))
             (archive-file (format "%s%s-%s.org" archive-dir start-day end-day)))

        (setq weekly-dir   archive-file)
        (setq org-archive-location (format "%s::** やったこと" archive-file))
        )
      (setq taskfile  "~/dropbox/inbox/inbox.org")
      (setq org-capture-templates
    	'(
    	  ("t" "ToDo" entry (file taskfile )
    	   "* TODO %^{title}\n %?")
    	  ("h" "Habit" entry (file "~/dropbox/habit.org")
    	   "* TODO %^{title}\n:PROPERTIES:\n:STYLE: habit\n:END:\n%?")
    	  ("p" "Project" entry (file+headline taskfile "プロジェクト" )
    	   "* PROJECT %^{title}[/]\n:PROPERTIES:\n:CATEGORY: %\\1\n:END:\n%?")
    	  ("w" "Weekly Report" entry (file weekly-dir)
    	   "* 今週のこと
    ,** やったこと
    ,** 時間計測
    ,#+BEGIN: clocktable :scope agenda-with-archives :maxlevel 10 :lang \"ja\" :block lastweek :wstart 6 :level 4
    ,#+END:
    ,** 考えたこと
    %?
    ,* 来週のこと
    ,** 予定
    %(my/org-agenda-to-string \"a\")
    ,** TODOリスト
    %(my/org-agenda-to-string \"d\")
    ,** 考えていること
    "))))
#+end_src
** org-refile
#+begin_src emacs-lisp :tangle yes
  (defun my-org-refile-verify-target ()
    "プロジェクト見出しの下にある全ての見出しを検証します。"
    (let ((path (org-get-outline-path)))
      (or (string= (car path) "プロジェクト")
          (member "プロジェクト" path))))

  (setq org-refile-target-verify-function 'my-org-refile-verify-target)
  (setq org-refile-targets '((nil . (:maxlevel . 9))))
#+end_src
** org-journal
#+begin_src emacs-lisp :tangle yes
  ;
#+end_src
** org-indent
#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'org-indent-mode))
#+end_src
** org-modern
#+begin_src emacs-lisp :tangle yes
    (autoload 'global-org-modern-mode "org-modern" nil t)
  (with-eval-after-load 'org
    (global-org-modern-mode))
  (with-eval-after-load 'org-modern
    (setq org-insert-heading-respect-content  t)
    (setq org-modern-star  "◉○●◈◇◆✸✳")
    (setq org-modern-todo-faces
  	 '(("SOMEDAY" :background "pink" :foreground "white" :weight bold)
  		("PROJECT" :background "purple" :foreground "white" :weight bold)
  		)))

#+end_src

** org-modern-indent
#+begin_src emacs-lisp :tangle yes
  ;(require 'org-modern-indent)
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90)
  (autoload 'org-modern-indent-mode "org-modern-indent" nil t)
#+end_src
** org-habit
#+begin_src emacs-lisp :tangle yes
  ;(use-package org-habit
  ;  :custom
  ;  (org-habit-show-habits-only-for-today  t)
  ;  :config
  ;  (add-to-list 'org-modules 'org-habit t)
  ;  )

#+end_src
** gcal
#+begin_src emacs-lisp :tangle yes
  ;(with-delayed-execution
  ;  (eval-after-load 'gcal
  ;    '(eval-after-load 'gcal-org
  ;       '(progn
  ;	  (setq gcal-client-id  "1005172243429-37v4n4shbp9dinr7h7ki5elu98nko9h4.apps.googleusercontent.com")
  ;	  (setq gcal-client-secret  (funcall(plist-get (nth 0 (auth-source-search :host "gcal")) :secret)))
  ;	  (gcal-org-pull-to-file
   ;   	   "shizhaoyoujie@gmail.com"
   ;   	   "~/dropbox/inbox/inbox.org"
   ;   	   "FROM_GCAL"
  ;    	   "~/dropbox/my-schedule.gcal-cache")
  ;	  (gcal-org-push-file
  ;    	   "shizhaoyoujie@gmail.com"
  ;    	   "~/dropbox/inbox/inbox.org"
  ;    	   "~/dropbox/my-schedule.gcal-cache")

  					; かなとの予定
  ;	  (gcal-org-pull-to-file "3512a1f6cb8f64e6d897c8e882de5910cef1a834fe96c1634963a76bd50e72dc@group.calendar.google.com"
  ;    				 "~/dropbox/kana.org"
  ;    				 "FROM_KANA"
  ;    				 "~/dropbox/kana-schedule.gcal-cache")
  ;	  (gcal-org-push-file
  ;  	   "3512a1f6cb8f64e6d897c8e882de5910cef1a834fe96c1634963a76bd50e72dc@group.calendar.google.com"
  ;  	   "~/dropbox/kana.org"
  ;  	   "~/dropbox/kana-schedule.gcal-cache")
  ;	  )
  ;       )
  ;    )
  ;  )

#+end_src
** org-babel
#+begin_src emacs-lisp :tangle yes
  (autoload 'org-babel-do-load-languages "org" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook
  	    #'(lambda ()
  		(org-babel-do-load-languages 'org-babel-load-languages
  					     '((emacs-lisp . t)
  					       (org . t)
  					       (shell . t)
  					       (plantuml . t)
  					       )))))
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src
*** org-nix-shell
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(org-nix-shell-mode) "org-nix-shell" nil t)

  (with-eval-after-load 'org
    (add-hook 'org-mode-hook #'org-nix-shell-mode))
#+end_src
** org-roam
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-c n l"  'org-roam-buffer-toggle)
  (keymap-global-set "C-c n f" 'org-roam-node-find)
  (keymap-global-set "C-c n i" 'org-roam-node-insert)
  (autoload 'org-roam-buffer-toggle "org-roam" nil t)
  (autoload 'org-roam-node-find "org-roam" nil t)
  (autoload 'org-roam-node-insert "org-roam" nil t)
  (with-eval-after-load 'org-roam
      (setq org-roam-directory  "~/dropbox/zk")
    (setq find-file-visit-truename   t)
    (setq org-roam-capture-templates
      '(("d" "default" plain "%?" :if-new
          (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}")
          :unnarrowed t
          :jump-to-captured t)

           ("p" "paper" plain "%?" :if-new
            (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
  ,#+filetags: :reference:paper:
  ,#+bibliography: ~/dropbox/ref.bib")
          :unnarrowed t
          :jump-to-captured t)
           ("b" "book" plain "%?" :if-new
            (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
  ,#+filetags: :reference:book:
  ,#+bibliography: ~/dropbox/ref.bib")
          :unnarrowed t
          :jump-to-captured t)
           ("a" "anime" plain "%?" :if-new
            (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
  ,#+filetags: :reference:anime:
  ,#+bibliography: ~/dropbox/ref.bib")
          :unnarrowed t
          :jump-to-captured t)
           ("m" "movie" plain "%?" :if-new
            (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
  ,#+filetags: :reference:movie:
  ,#+bibliography: ~/dropbox/ref.bib")
          :unnarrowed t
          :jump-to-captured t)
                 ("g" "game" plain "%?" :if-new
            (file+head "${slug}-%<%d-%m-%y>.org" "#+title: ${title}
  ,#+filetags: :reference:game:
  ,#+bibliography: ~/dropbox/ref.bib")
          :unnarrowed t
          :jump-to-captured t)
         )
     )
    (setq org-roam-node-display-template
  	(concat "${title:*} "
  		(propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    )
#+end_src
** org-roam-ui
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-c n u" 'org-roam-ui-open)
  (autoload 'org-roam-ui-open "org-roam-ui" nil t)
  (with-eval-after-load 'org-roam
    (setq org-roam-ui-sync-theme  t)
    (setq org-roam-ui-follow   t)
    (setq org-roam-ui-update-on-save  t)
    (setq org-roam-ui-open-on-start  t)
    )
#+end_src
** org-roam-review
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-c n r" 'org-roam-review)
  (autoload 'org-roam-review "org-roam-review" nil t)
  (autoload 'org-roam-review-list-by-maturity "org-roam-review" nil t)
  (autoload 'org-roam-review-list-recently-added "org-roam-review" nil t)
  (with-eval-after-load 'org-roam-review
    (add-hook 'org-roam-capture-new-node-hook #'org-roam-review-set-seedling)

    ;; カスタム削除関数の定義
    (defun org-roam-review-delete ()
      "Delete the current org-roam node file being reviewed."
      (interactive)
      (let* ((node (org-roam-node-at-point))
             (file-path (when node (org-roam-node-file node)))
             (title (when node (org-roam-node-title node)))
             (id (when node (org-roam-node-id node))))

        ;; ファイルの存在確認
        (unless (and file-path (file-exists-p file-path))
          (error "No valid file found for current node"))

        ;; バックリンクの確認（他のノートからリンクされているか）
        (let ((backlinks (org-roam-db-query
                         [:select [source]
                          :from links
                          :where (= dest $s1)]
                         id)))
          (when backlinks
            (unless (yes-or-no-p (format "'%s' has %d backlinks from other notes. Delete anyway? "
                                        title (length backlinks)))
              (user-error "Deletion cancelled"))))

        ;; 削除確認
        (when (yes-or-no-p (format "Delete '%s' permanently? " title))
          ;; 該当ファイルのバッファを閉じる
          (dolist (buffer (buffer-list))
            (when (equal (buffer-file-name buffer) file-path)
              (with-current-buffer buffer
                (set-buffer-modified-p nil)) ; 保存確認を避ける
              (kill-buffer buffer)))

          ;; ファイル削除
          (delete-file file-path)


          (message "Deleted: %s" title)

          ;; 次のレビューアイテムへ移動
  	(org-roam-review-refresh)
  	  )))

    (keymap-set org-mode-map "C-c r r" 'org-roam-review-accept)
    (keymap-set org-mode-map "C-c r f"  'org-roam-review-forgot)
    (keymap-set org-mode-map "C-c r u"  'org-roam-review-bury)
    (keymap-set org-mode-map "C-c r m"  'org-roam-review-set-memorise)
    (keymap-set org-mode-map "C-c r x"  'org-roam-review-set-excluded)
    (keymap-set org-mode-map "C-c r b"  'org-roam-review-set-budding)
    (keymap-set org-mode-map "C-c r s"  'org-roam-review-set-seedling)
    (keymap-set org-mode-map "C-c r e"  'org-roam-review-set-evergreen)
    (keymap-set org-roam-review-mode-map  "d"  'org-roam-review-delete)
    )
#+end_src
** citer
#+begin_src emacs-lisp :tangle yes
  (autoload 'org-cite-insert "citar" nil t)
  (with-eval-after-load 'citar
    (setq citar-bibliography  '("~/dropbox/ref.bib"))
    (keymap-set minibuffer-local-completion-map "s-j" 'icomplete-fido-exit)
    )
#+end_src
* Git
** diff-hl
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-startup-hook 'global-diff-hl-mode)
  (autoload 'global-diff-hl-mode "diff-hl" nil t)
  (with-eval-after-load 'diff-hl
    (setq diff-hl-flydiff-mode  t)
    (setq diff-hl-draw-borders  nil)
    )
#+end_src
** magit
#+begin_src emacs-lisp :tangle yes
  (autoload 'magit-status "magit" nil t)
  (keymap-global-set "C-x g" 'magit-status)
#+end_src
** forge
#+begin_src emacs-lisp :tangle yes
#+end_src
* flycheck
#+begin_src emacs-lisp :tangle yes
  (use-package flycheck-posframe
    :after flycheck posframe
    :config(flycheck-posframe-mode)
    )
  (autoload 'flycheck-mode "flycheck" nil t)
  (dolist (hook
  	 '(emacs-lisp-mode-hook
  	   org-mode-hook
  	   python-ts-mode-hook
  	   nix-ts-mode-hook
  	   rust-mode-hook
  	   rustic-mode-hook
  	   ))
    (add-hook hook #'flycheck-mode))
  (with-eval-after-load "flycheck"
    (flycheck-define-checker textlint
      "textlint."
      :command ("textlint" "--format" "unix"
                source-inplace)
      :error-patterns
      ((warning line-start (file-name) ":" line ":" column ": "
                (id (one-or-more (not (any " "))))
                (message (one-or-more not-newline)
                         (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                line-end))
      :modes (text-mode markdown-mode gfm-mode LaTeX-mode japanese-latex-mode))
    (add-to-list 'flycheck-checkers 'textlint)
    )
#+end_src
* Project
** projectile
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(projectile-mode
                       projectile-clear-known-projects
                       projectile-cleanup-known-projects) "projectile" nil t)

  (add-hook 'emacs-startup-hook #'projectile-mode)
  ( add-hook 'emacs-startup-hook #'my/update-projectile-known-projects )
  (defun my/update-projectile-known-projects ()
    (interactive)
    (projectile-clear-known-projects)
    (projectile-cleanup-known-projects)
    (setopt projectile-known-projects (mapcar
                                       (lambda (x)
                                         (abbreviate-file-name (concat x "/")))
                                       (split-string (shell-command-to-string "ghq list --full-path")))))
#+end_src
* PDF
#+begin_src emacs-lisp :tangle yes
  (autoload 'pdf-tools-install "pdf-tools" nil t)
  (autoload 'pdf-occur-global-minor-mode "pdf-occur" nil t)
  					;    (add-hook 'pdf-view-mode-hook (lambda() (nlinum-mode -1)))
  (add-hook 'emacs-startup-hook #'pdf-tools-install)
  #+end_src
* mistty
#+begin_src emacs-lisp :tangle yes
    (use-package mistty
      :custom
  					;(explicit-shell-file-name . "/home/kaki/.nix-profile/bin/fish")
      (mistty-shell-command  "/bin/bash")
    )
#+end_src
* helpful
#+begin_src emacs-lisp :tangle yes
  (autoload 'helpful-callable "helpful" nil t)
  (autoload 'helpful-function "helpful" nil t)
  (autoload 'helpful-macro "helpful" nil t)
  (autoload 'helpful-command "helpful" nil t)
  (autoload 'helpful-key "helpful" nil t)
  (autoload 'helpful-variable "helpful" nil t)
  (autoload 'helpful-at-point "helpful" nil t)

  (keymap-global-set "C-h f" #'helpful-callable)
  (keymap-global-set "C-h v" #'helpful-variable)
  (keymap-global-set "C-h k" #'helpful-key)
  (keymap-global-set "C-c C-d" #'helpful-at-point)
  (keymap-global-set "C-h F" #'helpful-function)
  (keymap-global-set "C-h C" #'helpful-command)
#+end_src
* Avy
#+begin_src emacs-lisp :tangle yes
  ;(use-package avy
  ;  :bind ("M-'" . avy-goto-char-timer)
  ;  )
  ;(defun avy-action-helpful (pt)
  ;  (save-excursion
  ;    (goto-char pt)
  ;    (helpful-at-point))
  ;  (select-window
  ;   (cdr (ring-ref avy-ring 0)))
  ;  t)
  ;(setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)
  ;(defun avy-action-embark (pt)
  ;  (unwind-protect
  ;      (save-excursion
  ;	(goto-char pt)
  ;	(embark-act))
  ;  (select-window
  ;   (cdr (ring-ref avy-ring 0))))
  ;  t)
  					;(setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)

  (keymap-global-set "M-'" 'avy-goto-char-timer)
  (autoload 'avy-goto-char-timer "avy" nil t)
  ;(with-eval-after-load 'avy
  ;  (defun avy-action-helpful (pt)
  ;  (save-excursion
  ;    (goto-char pt)
  ;    (helpful-at-point))
  ;  (select-window
  ;   (cdr (ring-ref avy-ring 0)))
  ;  t)
  ;(setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)
  ;(defun avy-action-embark (pt)
  ;  (unwind-protect
  ;      (save-excursion
  ;	(goto-char pt)
  ;	(embark-act))
  ;  (select-window
  ;   (cdr (ring-ref avy-ring 0))))
  ;  t)
  ;)
#+end_src
* ace-window
#+begin_src emacs-lisp :tangle yes
  (keymap-global-set "C-x o" 'ace-window)
  (autoload 'ace-window "ace-window" nil t)
#+end_src
* embark
#+begin_src emacs-lisp :tangle yes
  (autoload 'embark-act "embark" nil t)
  (with-eval-after-load 'embark
    (setq prefix-help-command #'embark-prefix-help-command)
    (require 'embark-consult)
    )
#+end_src
* go-translate
#+begin_src emacs-lisp :tangle yes
    (use-package go-translate
      :defer t
      :config
      (setq gt-langs '(en ja))
      (setq gt-default-translator
  	  (gt-translator
  	   :taker (gt-taker :text 'buffer :pick 'paragraph)
  	   :engines (list (gt-deepl-engine :key  (funcall(plist-get (nth 0 (auth-source-search :host "deepl")) :secret))))
  	   :render (gt-buffer-render :then (gt-kill-ring-render))
  	   ))
  					; :bind (
  					;	 ("C-t" . gt-do-translate)
  					;	 )
      )

#+end_src
* quick-sdcv
#+begin_src emacs-lisp :tangle yes
  (autoload-if-found '(quiqk-sdcv-search-at-point quick-sdcv-search-input) "quick-sdcv" nil t)
  (with-eval-after-load 'quick-sdcv
    (setq quick-sdcv-dictionary-prefix-symbol "►")
    (setq quick-sdcv-ellipsis " ▼")
    )
#+end_src
* reinbow-delimiters
#+begin_src emacs-lisp :tangle yes
  (require 'rainbow-delimiters)
  (add-hook 'emacs-mode #'rainbow-delimiters-mode)
#+end_src
* reformatter
#+begin_src emacs-lisp :tangle yes
  ;(use-package reformatter
  ;   )
  ;  (reformatter-define nixfmt
  ;    :program "nixfmt"
  ;    :args '("-")
  ;    )
  ;  (reformatter-define ruff
  ;    :program "ruff format"
  ;    :args '("-")
  ;    )
    ;)
#+end_src
* apheleia
#+begin_src emacs-lisp :tangle yes
  (autoload 'apheleia-global-mode "apheleia")
  (apheleia-global-mode)
  ;(setf (alist-get 'nix-ts-mode apheleia-mode-alist) 'nixfmt)
    (setf (alist-get 'typst-ts-mode apheleia-mode-alist) 'typstmt)
#+end_src
* aggressive-inden
* プログラミング支援
** eglot
#+begin_src emacs-lisp :tangle yes
  ;(use-package eglot
  ;  :defer-config
  ;  (add-to-list 'eglot-server-programs
  ;	       '((nix-ts-mode . ("nil"))
  					;	       (typst-ts-mode . ("tinymist")))
  ;	       '(nix-ts-mode . ("nil"))
  ;               )
  ;  (add-to-list 'eglot-server-programs
  ;	       '(typst-ts-mode . ("tinymist")))
  ;  )
  ;(use-package eglot-booster
  ;  :when (executable-find "emacs-lsp-booster")
  ;  :vc ( :url "https://github.com/jdtsmith/eglot-booster")
  ;  :global-minor-mode t)
#+end_src

** envrc
#+begin_src emacs-lisp :tangle yes
  (autoload 'envrc-global-mode "envrc" nil t)
  (add-hook 'emacs-startup-hook #'envrc-global-mode)
  (with-eval-after-load 'envrc
    (setq  Info-directory-list Info-default-directory-list )
    )
#+end_src

** inheritenv
#+begin_src emacs-lisp :tangle yes
  ;(require 'inheritenv)
  ;(eval-after-load 'rustic
  ;  (inheritenv-add-advice #'rustic-compilation))
#+end_src

* tramp
#+begin_src emacs-lisp :tangle yes
        					;(with-eval-after-load "tramp"
        					;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)
        					;  )
        					;(add-to-list 'tramp-remote-path "/run/current-system/sw/bin")
    (customize-set-variable 'tramp-use-connection-share nil)
  (setq tramp-use-ssh-controlmaster-options nil)
    (setq tramp-verbose 6)
    (setq tramp-debug-buffer t)

    (require 'tramp-sh)
    (setq tramp-remote-path
          (append tramp-remote-path
           	      '(tramp-own-remote-path)))

    (setq remote-file-name-inhibit-locks t
          tramp-use-scp-direct-remote-copying t
          remote-file-name-inhibit-auto-save-visited t)

    (setq tramp-copy-size-limit (* 1024 1024) ;; 1MB
          )

        					; use direct async
    (connection-local-set-profile-variables
     'remote-direct-async-process
     '((tramp-direct-async-process . t)))

    (connection-local-set-profiles
     '(:application tramp :protocol "scp")
     'remote-direct-async-process)

    (setq magit-tramp-pipe-stty-settings 'pty)


    ;; don't show the diff by default in the commit buffer. Use `C-c C-d' to display it
    (setq magit-commit-show-diff nil)
    ;; don't show git variables in magit branch
    (setq magit-branch-direct-configure nil)
    ;; don't automatically refresh the status buffer after running a git command
    (setq magit-refresh-status-buffer nil)


    (defun memoize-remote (key cache orig-fn &rest args)
    "Memoize a value if the key is a remote path."
    (if (and key
             (file-remote-p key))
        (if-let ((current (assoc key (symbol-value cache))))
            (cdr current)
          (let ((current (apply orig-fn args)))
            (set cache (cons (cons key current) (symbol-value cache)))
            current))
      (apply orig-fn args)))

    ;; Memoize current project
  (defvar project-current-cache nil)
  (defun memoize-project-current (orig &optional prompt directory)
    (memoize-remote (or directory
                         project-current-directory-override
                         default-directory)
                     'project-current-cache orig prompt directory))

  (advice-add 'project-current :around #'memoize-project-current)

  ;; Memoize magit top level
  (defvar magit-toplevel-cache nil)
  (defun memoize-magit-toplevel (orig &optional directory)
    (memoize-remote (or directory default-directory)
                     'magit-toplevel-cache orig directory))
  (advice-add 'magit-toplevel :around #'memoize-magit-toplevel)

  ;; memoize vc-git-root
  (defvar vc-git-root-cache nil)
  (defun memoize-vc-git-root (orig file)
    (let ((value (memoize-remote (file-name-directory file) 'vc-git-root-cache orig file)))
      ;; sometimes vc-git-root returns nil even when there is a root there
      (when (null (cdr (car vc-git-root-cache)))
        (setq vc-git-root-cache (cdr vc-git-root-cache)))
      value))
  (advice-add 'vc-git-root :around #'memoize-vc-git-root)

  ;; memoize all git candidates in the current project
  (defvar $counsel-git-cands-cache nil)
  (defun $memoize-counsel-git-cands (orig dir)
    ($memoize-remote (magit-toplevel dir) '$counsel-git-cands-cache orig dir))
  (advice-add 'counsel-git-cands :around #'$memoize-counsel-git-cands)
#+end_src
* Dired
** dired-narrow
#+begin_src emacs-lisp :tangle yes
  (use-package dired-narrow
    :after dired-hacks-utils
    :bind
    (:map dired-mode-map
     ("," . dired-narrow-fuzzy)
     )
  )
#+end_src
** nerd-icons-dired
#+begin_src emacs-lisp :tangle yes
  (autoload 'nerd-icons-dired-mode "nerd-icons-dired" nil t)

  (with-eval-after-load 'dired-mode
    (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))
#+end_src
* mu4e
#+begin_src emacs-lisp :tangle yes
    (setq mail-user-agent 'mu4e-user-agent)
#+end_src
* vterm
#+begin_src emacs-lisp :tangle yes
  (setq vterm-keymap-exceptions '("C-c" "C-y" "M-v" "M-x"))
  (autoload 'vterm-toggle "vterm-toggle" nil t)
  (with-eval-after-load 'vterm-toggle
    (setq vterm-toggle-scope 'project)
    )
  (with-eval-after-load 'vterm
    (setq vterm-tramp-shells  '(("ssh" "'fish'") ("scp" login-shell) ("docker" "/bin/sh")))
    (keymap-set vterm-mode-map "C-c C-c" 'vterm--self-insert)
    )
  (keymap-global-set "M-v" #'vterm-toggle)
#+end_src
* Slack
#+begin_src emacs-lisp :tangle yes
  (setq auth-sources '("~/.config/emacs/.authinfo.gpg"))

  (autoload 'slack-im-open "slack" nil t)
  (with-eval-after-load 'slack
    (slack-register-team
     :name "mdip"
     :token (funcall(plist-get (nth 0 (auth-source-search :machine "mdip.slack.com" :port "token")) :secret))
     :cookie (funcall(plist-get (nth 0 (auth-source-search :machine "mdip.slack.com" :port "cookie")) :secret))
     :default t
     )
    (define-key slack-mode-map (kbd "S-<return>")
  (lambda () (interactive) (insert (kbd "C-j"))))
    )
#+end_src
** slack-org
org-store-linkでリンクをコピーすることができる。
TODOに貼っておくことで、作業の際に確認することができるようになる。
#+begin_src emacs-lisp :tangle yes
#+end_src
* 履歴保存
bufferが溜ったり、設定が更新されなかったり、ssh先が保存されなかったり、いまいちなことが多いので一旦無効化する。
#+begin_src emacs-lisp :tangle yes
  ; (leaf desktop
   ;  :custom
   ;  (desktop-save-mode . 1)
   ;  )
   ;(profiler-report) ;; Profiler report removed
   ;(profiler-stop) ;; Profiler stop removed
  (setq file-name-handler-alist my-saved-file-name-handler-alist)
#+end_src
